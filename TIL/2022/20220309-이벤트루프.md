# 이벤트 루프

ref: https://tecoble.techcourse.co.kr/post/2021-08-28-event-loop/

- 프로세스
  - 운영체제가 프로그램의 실행을 위해 프로그램에 메모리를 할당하는 단위
- 스레드
  - 프로세스가 할당받은 메모리를 실행하는 단위. 하나의 프로세스가 여러 스레드로 나뉠 수 있음.
- task queue
  - 콜 스택에 들어가기 전에 setTimeout, 사용자 이벤트 콜백 등이 저장되는 큐
- microtask queue
  - Promise.then 콜백이 저장되는 큐

### 이벤트 루프

- 브라우저 메인 스레드 동작 타이밍 관리자 라고 할 수 있음
- 여기서 메인 스레드란 자바스크립트 코드 실행이나 브라우저 렌더링을 맡는 등 브라우저의 주된 동작이 수행되는 곳

### 이벤트 루프 중요 이유

1. 브라우저 동작의 대부분이 메인 스레드에서 싱글 스레드로 실행됨.
   - 웹 api에서 제공하는 비동기 함수들(예: fetch, setTimeout)과 워커 종류를 제외한 대부분의 자바스크립트 코드가 메인 스레드라는 곳에서 실행됨. 또한 브라우저 화면을 그리는 렌더링 작업도 이곳에서 실행됨. 이처럼 브라우저의 주요한 동작들이 메인 스레드라는 하나의 싱글 스레드로 동작함.
   - 여기서 메인 스레드가 싱글 스레드로 동작하는 것이 중요한 이유는 싱글 스레드에서 하나의 작업을 하고 있다면 다른 작업은 지연시키기 때문임. 개발자가 만약 자바스크립트 코드에 무한 루프 코드를 작성한다면 해당 작업이 다른 모든 작업을 지연시키고 메인 스레드에서 무한히 동작할 것임. 결국에는 브라우저 먹통. 사용자 이벤트도 메인 스레드에서 동작하기 때문에 키보드 입력이나 마우스 클릭도 동작하지 않음. 그러므로 싱글 스레드의 작업 관리는 매우 중요함.
2. 메인 스레드는 이벤트 루프에 의해 관리됨.
   - 메인 스레드와 같은 싱글 스레드에서 하나의 작업이 오랫동안 실행되어서도 안 되고, 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인가 결정하는 것도 매우 중요함. 또한 작업 간 전환 속도를 빠르게 하여 한번에 하나의 작업씩 수행하지만 마치 동시에 수행하는 것처럼 동작해야 함.(참고 - [동시성과 병렬성](https://www.charlezz.com/?p=44646))
   - 이러한 섬세한 컨트롤을 이벤트 루프가 함.

### 이벤트 루프의 동작

![https://media.giphy.com/media/41qMCw6byUsNjqeie0/giphy.gif?cid=790b76110b521df01c236df35e6f56e004135ad84c50bd9e&rid=giphy.gif&ct=g](https://media.giphy.com/media/41qMCw6byUsNjqeie0/giphy.gif?cid=790b76110b521df01c236df35e6f56e004135ad84c50bd9e&rid=giphy.gif&ct=g)

- 그림 상
  - T: task queue
  - raF: requestAnimationFrame
  - S: Style (렌더 트리 생성)
  - L: Layout
  - P: Paint

중앙을 기준으로 왼쪽 path가 task queue, 오른쪽 path가 브라우저 렌더링이라고 생각하면 됨. (microtask는 그림 어디에서나 실행될 수 있다고 함.)

1. 초기 콜 스택에 쌓여있는 task를 모두 처리

   처음 html을 가져오고 script 태그를 만나는 순간을 생각해보자. 브라우저 렌더링 과정에 들어가기 전에 동작을 잠깐 멈추고 자바스크립트 코드를 읽기 시작함. 자바스크립트 코드가 DOM 트리를 수정할 수 있기 때문임. 이 과정에서 코드들이 콜 스택에 올라가 동작을 수행하게 되고 Promise나 setTimeout과 같은 비동기 관련 콜백들이 queue에 등록됨.

2. Promise.then 콜백이 microtask queue에 등록되어 있다면 실행

   처음 콜 스택에 있는 코드들이 모두 실행되고 난 후부터는 Promsie가 가장 높은 우선순위를 차지함.

   Promise.then 콜백이 등록된 microtask queue는 queue에 등록된 모든 콜백이 처리될 때 까지 계속 수행한다는 특징이 있음.

3. 화면 갱신이 필요하다면 렌더링 파이프라인으로 이동(requestAnimationFrame(rAF))

   화면 갱신이 필요하다는 것은 이벤트 루프가 판단함. 사용자가 스크롤 이동을 했거나, 어떤 요소를 클릭했거나 등등 화면을 갱신해야 될 필요가 있다면 렌더링 파이프라인으로 이동함.(그림에서 오른쪽 path)

   여기서 자바스크립트 코드 상에 rAF api를 사용하면 이벤트 루프가 모니터 주사율(Hz)에 맞춰 렌더링 파이프라인으로 들어가려고 노력함. (싱글 스레드이기 때문에 반드시 주기가 지켜지는 것은 아님)

4. task queue에 있는 콜백을 하나씩 실행. (setTimeout)

   queue에 있는 콜백을 하나씩 실행한다는 것은 Promise와는 다르게 task queue는 콜백을 하나 실행하고 이벤트 루프를 놓아주어 다른 동작을 수행할 수 있도록 한다는 것. 재귀적으로 setTimeout 콜백을 task queue에 집어넣어도, 브라우저는 정상 작동함.(Promise를 재귀적으로 실행할 경우 먹통)

### requestAnimationFrame vs setTimeout

rAF와 setTimeout의 가장 큰 차이점은 1프레임 당 호출이 보장되느냐 되지 않느냐의 차이가 있음. 흔히 웹에서 애니메이션을 보여주기 위해 setTimeout 대신 rAF 사용을 권장함. 그 이유는 애니메이션을 위해 setTimeout을 16ms마다 동작하도록 코드를 작성하여도, 다른 task에 의해서 지연될 가능성이 있어 1프레임당 1번의 호출이 보장되지 않기 때문임.

위 그림을 보면 setTimeout은 task queue에 올라가 동작하고, rAF는 렌더링 파이프라인과 붙어 동작하는 것을 확인할 수 있음. 이런 구조 상 rAF는 무조건 1프레임 당 1번의 호출이 보장되고 setTimeout은 지연되어 2프레임 당 1번, 또는 3프레임당 1번 호출될 가능성도 있음. 이런 현상은 버벅거리는 애니메이션을 제공하여 사용자 경험을 떨어뜨림.
