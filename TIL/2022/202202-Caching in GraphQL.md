# **Caching in GraphQL: How to prevent excessive and unnecessary requests**

**What is caching?**

캐싱은 다양한 분야에서 사용되는 장기 최적화 트릭입니다. 동일한 행동을 두 번 수행하지 않는 것을 의미합니다. action을 수행하고 action의 결과를 저장하고, 동일한 action을 다시 수행할 때 action을 수행하지 않고 이전에 저장된 결과를 검색하여 반환합니다.

결과가 저장되는 장소를 캐시라고 합니다.

여기서 질문은 다음과 같습니다. 동일한 작업을 수행할 때를 어떻게 알 수 있습니까? 고유성을 어떻게 식별합니까?

캐시에서 결과는 키-값 쌍에 저장됩니다. 따라서 작업이 수행된 시점을 알기 위해 캐시 키를 사용하여 들어오는 항목과 일치시킵니다. 따라서 모든 작업에는 고유성이 있습니다. 고유성은 캐시 키에 저장되는 것으로, 일치하는 항목이 일치하면 서로 비교하여 캐시 값에서 값을 반환합니다. 일치하는 항목이 없으면 작업이 수행되고 결과가 캐시에 저장되므로 나중에 캐시에서 결과가 반환됩니다.

**HTTP 캐싱**

HTTP 캐시는 서버에 대한 HTTP 요청 캐싱을 포함합니다.

HTTP 캐시를 사용하여 웹 사이트의 대기 시간과 네트워크 트래픽을 줄일 수 있습니다.

HTTP 캐시에는 브라우저 캐시, 프록시 캐시, 게이트웨이 캐시, CDN, 역방향 프록시 캐시 및 로드 밸런서가 있습니다.

브라우저 캐시는 개인 HTTP 캐시입니다. 브라우저는 네트워크 요청에 대한 응답을 내부 저장소에 캐시합니다. 페이지 또는 XHR에 대한 네트워크 요청이 만들어지면 문서는 서버에서 가져오고 브라우저는 문서를 캐시합니다. 이제 다음에 동일한 요청이 수행되면 브라우저는 서버로 이동하지 않고 캐시에서 바로 응답을 검색합니다. 이렇게 하면 문서가 매우 빠르게 로드되어 사용자 데이터를 동시에 저장합니다.

이는 또한 브라우저가 오프라인일 때 브라우저가 캐시에서 문서를 검색하는 데 유용합니다.

HTTP 캐시는 서버에 쓰지 않고 서버에서 읽기만 하기 때문에 주로 GET에서 작동합니다. 다른 HTTP 메서드(POST, PUT, DELETE)는 캐시가 거부됩니다. 그렇게 하면 데이터가 손실되고 잘못된 정보가 표시될 수 있기 때문입니다.

**서버는 Cache-Control** 및 **Expires** 헤더 를 사용하여 응답 의 **최신성** 을 알려줄 수 있습니다.

이 **신선함** 은 무엇입니까 ?

캐시에 오랫동안 저장된 항목은 오래될 수 있습니다. 즉, 서버의 값이 변경되어 캐시를 **새로 고쳐야** 서버에서 와 같이 캐시가 최신 값으로 설정됩니다.

```html
Cache-Control: max-age=100
```

캐시의 신선도는 100초 동안 유지되어 부실하거나 오래되어 캐시가 새 값으로 새로 고쳐집니다.

**GraphQL 캐싱**

위 섹션에서 본 RESTful API에서 우리는 GET API를 캐싱하기 쉽고 다른 HTTP 메소드는 캐싱하기 쉽지 않거나 직접 캐싱할 수 없다는 것을 배웠습니다.

RESTful API는 각 GET 요청을 식별하는 데 사용되는 **전역 고유 식별자 인 URL을 사용합니다.** 이 URL을 활용하여 캐시를 만들 수 있습니다. URL은 캐시 저장소의 키-값 쌍에서 키로 사용되며 응답은 값이 됩니다.

전역적으로 고유한 식별자라는 것은 URL이 고유하고 중복될 수 없음을 의미합니다.

GraphQL에서 POST HTTP 메서드는 쿼리를 수행하는 데 사용되며 RESTful API와 같은 URL과 유사한 끝점이 없습니다.

이것은 GraphQL 쿼리를 캐싱하기 어렵게 만듭니다.
