# Traits: Defining Shared Behavior

A _trait_ tells the Rust compiler
about functionality a particular type has and can share with other types.
We can use tratis to define shared in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.

```
Note: Traits are similar to a feature ofthen called _interfaces_ in other languages, although with some differences.
```

## Defining a Trait

A type's behavior consists of the methods we can call on that type.
Different types share the same behavior if we can call the same methods on all of those types.
Trait definitions are a way to group method signatures together to define a set of behavior necessary to accomplish some purpose.

For example, let's say we have multiple structs that hold various kinds and amounts of text:
a `NewsArticle` struct that holds a news story field in a particular location and a `Tweet` that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.

We want to make a media aggregator library that can display summaries of data that might be stored in a `NewsArticle` or `Tweet` instance.
To do this, we need a summary from each type,
and we need to request that summary by calling a `summarize` method on an instance.
Listing 10-12 shows the definition of a `Summary` trait that expresses this behavior.

Filename: src/lib.rs

```rs
pub trait Summary {
    fn summarize(&self) -> String;
}
```

Listing 10-12: A `Summary` trait that consists of the behavior provided by a `summarize` method

Here, we declare a trait using the `trait` keyword and then the trait's name, which is `Summary` in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is `fn summarize(&self) -> String`.

After the method signature, instead of providing an implementation within curly brackets, we use a semicolon.
Each type implementing this trait must provide its own custom behavior for the body of the method.
The compiler will enforce that any type that has the `Summary` trait will have the method `summarize` defined with this signature exactly.

A trait can have multiple methods in its body:
the method signatures are listed one per line and each line ends in a semicolon.

## Implementing a Trait on a Type

Now that we've defined the desired behavior using the `Summary` trait,
we can implement it on the types in our media aggregator.
Listing 10-13 shows an implementation of the `Summary` trait on the `NewsArticle` struct that uses the headline, the authro, and the location to create the return value of `summarize`.
For the `Tweet` struct,
we define `summarize` as the username followed by the entire text of the tweet,
assuming that tweet content is already limited to 280 characters.

Filename: src/lib.rs

```rs
pub struct NewsArticle {
    pub haedline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

Listing 10-13: Implementing the `Summary` trait on the `NewsArticle` and `Tweet` types

Implementing a trait on a type is similar to implementing regular methods.
The difference is that after `impl`,
we put the trait name that we want to implement,
then use the `for` keyword,
and then specify the name of the type we want to implement the trait for.
Within the `impl` block,
we put the method signatures that the trait definition has defined.
Instead of adding a semicolon after each signature,
we use curly brackets and fill in the method body
with the specify behavior that we want the methods of the trait to have for the particular type.

After implementing the trait,
we can call methods on instances of `NewsArticle` and `Tweet` in the same way we call regular methods,
like this:

```rs
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("
            of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
```

This code prints `1 new tweet: horse_ebooks: of course, as you probably already know, people.`

Note that because we defined the `Summary` trait and the `NewsArticle` and `Tweet` types in the same _lib.rs_ in Listing 10-13, they’re all in the same scope. Let’s say this _lib.rs_ is for a crate we’ve called `aggregator` and someone else wants to use our crate’s functionality to implement the `Summary` trait on a struct defined within their library’s scope. They would need to bring the trait into their scope first. They would do so by specifying `use aggregator::Summary;`, which then would enable them to implement `Summary` for their type. The `Summary` trait would also need to be a public trait for another crate to implement it, which it is because we put the `pub` keyword before `trait` in Listing 10-12.

One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like `Display` on a custom type like `Tweet` as part of our `aggregator` crate functionality, because the type `Tweet` is local to our `aggregator` crate. We can also implement `Summary` on `Vec<T>` in our `aggregator` crate, because the trait `Summary` is local to our `aggregator` crate.

But we can’t implement external traits on external types. For example, we can’t implement the `Display` trait on `Vec<T>` within our `aggregator` crate, because `Display` and `Vec<T>` are defined in the standard library and aren’t local to our `aggregator` crate. This restriction is part of a property of programs called _coherence_, and more specifically the _orphan rule_, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.

## Default Implementations

Sometimes it's useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type,
we can keep or override each method's default behavior.

Listing 10-14 shows how to specify a default string for the `summarize` method of the `Sumamry` trait instead of only defining the method signature,
as we did in Listing 10-12.

Filename: src/lib.rs

````rs
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
```rs
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
````

Listing 10-14: Definition of a `Summary` trait with a default implementation of the `summarize` method

To use a default implementation
to summarize instances of `NewsArticle` instead of defining a custom implementation,
we specify an empty `impl` block with `impl Summary for NewsArticle {}`.

Even though we're no longer defining the `summarize` method on `NewsArticle` directly,
we've provided a default implementation and specified that `NewsArticle` implements the `Summary` trait.
As a result, we can still call the `summarize` method on an instance of `NewsArticle`, like this:

```rs
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
            hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
```

This code prints
`New article available! (Read more...)`.

Creating a default implementation for `summarize`
doesn't require us to change anything about the implementaion
of `Summary` on `Tweet` in Listing 10-13.
The reason is that
the syntax for overriding a default implementation is the same as
the syntax for implementing a trait method that doesn't have a default implementation.

Default implementations can call other methods in the same trait,
even if those other methods don't have a default implementaion.
In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it.
To use this version of `Summary`, we only need to define `summarize_author` when we implement the trait on a type:

```rs
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

After we define `summarize_author`,
we can call `summarize` on instances of the `Tweet` struct,
and the default implementation of `summarize` will call the definition
of `summarize_author` that we've provided.
Because we've implemented `summarize_author`,
the `Summary` trait has given us the behavior of the `summarize` method without requiring us to write any more code.

```rs
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
```

This code prints `1 new tweet: (Read more from @horse_ebooks...)`.

Note that it isn't possible to call the default implementation from an overriding implementation of that same method.

## Traits as Parameters

Now that you know how to define and implement traits,
we can explore how to use traits to define functions
that accept many different types.

For example, in Listing 10-13, we implemented the `Summary` trait on the `NewsArticle` and `Tweet` types.
We can define a `notify` function that calls the `summarize` method on its `item` parameter, which is of some type that implements
the `Summary` trait.
To do this, we can use the `impl Trait` syntax, like this:

```rs
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

Instead of a concrete type for the `item` parameter,
we specify the `impl` keyword and the trait name.
This parameter accepts any type
that implements the specified trait.
In the body of `notify`,
we can call any methods on `item` that come from the `Summary` trait,
such as `summarize`.
We can call `notify` and pass in any instance of `NewsArticle` or `Tweet`.
Code that calls the function with any other type,
such as a `String` or an `i32`,
won't compile because those types don't implement `Summary`.

### Trait Bound Syntax

The `impl Trait` syntax works for straightforward cases
but is actually syntax susgar for a longer form,
which is called a _trait bound_; it look like this:

```rs
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

This longer form is equivalent to the example in the previous section but is more verbose.
We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.

The `impl Trait` syntax is convenient and makes for more concise code in in simple cases.
The trait bound syntax can express more complexity in other cases.
For example, we can have two parameters that implement `Summary`.
Using the `impl Trait` syntax looks like this:

```rs
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

If we wanted this function to allow `item1` and `item2` to have different types,
using `impl Trait` would be appropriate (as long as both types implement `Summary`).
If we wanted to force both parameters to have same type,
that's only possible to express using a trait bound,
like this:

```rs
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

The generic type `T` specified as the type of the `item1` and `item2` parameters constrains the function such that the concrete type of the value passed as an argument for `item1` and `item2` must be the same.

### Specifying Multiple Trait Bounds with the + Syntax

We can also specify more than one trait bound.
Say we wanted `notify` to use display formatting on `item` as well as the `summarize` method:
we specify in the `notify` definition that `item` must implement both
`Display` and `Summary`.
We can do so using the `+` Syntax:

```rs
pub fn notify(item: &(impl Summary + Display)) {
```

The `+` syntax is also valid with trait bounds on generic types:

```rs
pub fn notify<T: Summary + Display>(item: &T) {
```

With the two trait bounds specified,
the body of `notify` can call `summarize` and use `{}` to format item.

## Clear Trait Bounds with `where` Clauses

Using too many trait bounds has its downsides.
Each generic has its own trait bounds,
so functions with multiple generic type parameters can contain lots of
trait bound information
between the function's name and its parameter list,
making the function signature hard to read.
For this reason,
Rust has alternate syntax for specifying
trait bounds inside a `where` clause after the function signature. So instead of writing this:

```rs
fn some_function<T: Display + Close, U: Clonse + Debug>(t: &T, u: &U) -> i32 {
```

we can use a `where` clause, like this:

```rs
fn some_function<T, U>(t: &T, u: &U) -> i32
    where: T: Display + Clone,
           U: Clone + Debug
{
```

This function's signauter is less cluttered:
the function name,
parameter list, and return type are close together,
similar to a function without lots of
trait bounds.
