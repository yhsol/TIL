# Vlidating References with Lifetimes

One detail we didnt' discuss in the "References and Borrowing" section in Chapter 4 is that every reference in Rust has a _lifetime_,
which is the scope for which that reference is valid.
Most of the time, lifetimes are implicit and inferred,
just like most of the time,
types are inferred.
We must annotate types when multiple types are possible.
In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways.
Rust requires us to annotate
the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.

The concept of lifetimes is somewhat different from tools in other programming languages,
arguably making lifetimes Rust's most distinctive feature.
Although we won't cover lifetimes in their entirety in this chapter,
we'll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.

## Preventing Dangling References with Lifetimes

The main aim of lifetimes is to prevent dangling references,
which cause a program to reference data other that the data it's intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner scope.

```rs
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
```

Listing 10-17: An attempt to use a reference whose value has gone out of scope

```
Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value,
so the variable name exists in the outer scope.
At first glance, this might appear to be in conflict with Rust's having no null values.
However, if we try to use a variable before giving it a value,
we'll get a compile-time error,
which shows that Rust indeed does not allow null values.
```

The outer scope declares a variable named `r` with no initial value,
and the inner scope declares a variable named `x` with the initial value of 5.
Inside the inner scope, we attempt to set the value of `r` as a reference to `x`.
Then the inner scope ends, and we attempt to print the value in `r`.
This code won't compile because the value `r` is referring to has gone out of scope before we try to use it.
Here is the error message:

```
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`

To learn more, run the command again with --verbose.
```

The variable `x` doesn't "live long enough." The reason is that `x` will be out of scope when the inner scope ends on line 7.
But `r` is still valid for the outer scope;
because its scope is larger,
we say that it "lives longer".
If Rust allowed this code to work,
`r` would be referencing memory that was deallocated when `x` when out of scope,
and anything we tried to do with `r` wouldn't work correctly.
So how does Rust determine that this code is invalid?
It uses a borrow checker.

## The Borrow Checker

The Rust compiler has a _borrow checker_ that compares scopes to determine whether all borrows are valid.
Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.
