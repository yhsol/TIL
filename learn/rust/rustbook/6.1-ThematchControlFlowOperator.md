# The `match` Control Flow Operator

Rust has an extremely powerful control flow operator called `match`
that allows you
to compare a value against a series of patterns
and then execute code
based on which pattern matches.
Patterns can be made up of literal values,
variable names,
wildcards,
and many other things;
Chapter 18 covers all the different kinds of patterns
and what they do.
The power of `match` comes from the expressiveness
of the patterns and
the fact that the compiler confirms that all possible cases are handled.

Think of a `match` expression as being like a coin-sorting machine:
coins clide down a track
with variously sized holes along it,
and each coin falls through the first hole it
encounters that it fits into.
In the same way,
values go though each pattern in a `match`,
and at the first pattern
the value "fits,"
the value falls into the associated code block
to be used during execution.

Because we just mentioned coins,
let's use them
as an example using `match`!
We can write a function
that can take an unknown United States coin and,
in a similar way
as the counting machine,
determine which coin it is and
return its value in cents,
as shown here in Listing 6-3.

```rs
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

Listing 6-3: An enum and a match expression that has the variants of the enum as its patterns

Let's break down
the `match` in the
`value_in_cents` function.
First,
we list the `match` keyword
followed by an expression,
which in this case is the value `coin`.
This seems very similar
to an expression used with `if`,
but there's a big difference:
with `if`,
the expression needs to return a Boolean value,
but here,
it can be any type.
The type of `coin` in this example
is the `Coin` enum that we defined on line 1.

Nest are the `match` arms.
An arm has two parts:
a pattern and some code.
The first arm here
has a pattern that is the value `Coin::Penny`
and then the `=>` operator that separates
the pattern and the code to run.
The code in this case is just the value `1`.
Each arm is separated from the next with a comma.
