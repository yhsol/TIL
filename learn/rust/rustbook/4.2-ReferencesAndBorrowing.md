# References and Borrowing

- 앞 절의 마지막에 등장한 튜플일 이용하는 이슈는 `String`을 호출하는 함수 쪽으로 반환함으로써 `calculate_length`를 호출한 이후에도 여전히 `String`을 이요할 수 있도록 하는 것인데, 그 이유는 `String`이 `calculate_length` 안쪽으로 이동되었기 때문

- 소유권을 넘기는 대신 개체에 대한 참조자(reference)를 인자로 사용하는 `calculate_length` 함수를 정의하고 이용하는 방법이 있다.
  Filename: src/main.rs

```rs
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

첫번째로, 변수 선언부와 함수 반환값에 있던 튜플 코드가 모두 없어진 것에 주목하세요.
두번째로, `calcuate_length` 함수에 `&s1`를 넘기고,
함수의 정의 부분에는 `String`이 아니라 `&String`을 이용했다는 점을 기억하세요.

이 엠퍼센드(&) 기호가 *참조자*이며,
이는 여러분이 어떤 값을 소유권을 넘기지 않고 참조할수 있도록 해줍니다.
Figure 4-8은 이에 대한 다이어그램입니다.

```
image
```

Figure 4-8: `String s1`을 가리키고 있는 `&String s`

함수 호출 부분을 좀 더 자세히 봅시다.:

```rs
let s1 = String::from("hello");

let len = calculate_length(&s1);
```

`&s1` 문법은 우리가 `s1`의 값을 *참조*하지만 소유하지는 않는 참조자를 생성하도록 해줍니다.
소유권을 갖고 있지는 않기 때문에, 이 참조자가 가리키는 값은 참조자가 스코프 밖으로 벗어났을 때도 메모리가 반납되지 않을 것입니다.

비슷한 이치로, 함수 시그니처도 `&`를 사용하여 인자 `s`의 타입이 참조자라는 것을 나타내고 있습니다.
설명을 위한 주석을 달아봅시다:

```rs
fn calculate_length(s: &String) -> usize { // s는 String의 참조자입니다
  s.len()
} // 여기서 s는 스코프 밖으로 벗어났습니다. 하지만 가리키고 있는 값에 대한 소유권이 없기
// 때문에, 아무런 일도 발생하지 않습니다.
```

변수 `s`가 유효한 스코프는 여느 함수의 파라미터의 스코프와 동일하지만, 소유권을 갖고 있지 않으므로 이 참조자가 스코프 밖으로 벗어났을 때 참조자가 가리키고 있는 값은 버리지 않습니다. 또한 실제 값 대신 참조자를 파라미터로 갖고 있는 함수는 소유권을 갖고 있지 않기 때문에 소유권을 되돌려주기 위해 값을 다시 반환할 필요도 없다는 뜻이 됩니다.

함수의 파라미터로 참조자를 만드는 것을 *빌림*이라고 부릅니다. 실제 생활에서 만일 어떤 사람이 뭔가를 소유하고 있다면, 여러분은 그걸 빌릴 수 있습니다. 여러분의 용무가 끝났을 때는 그것을 돌려주어야 합니다.

그러니까 만일 우리가 빌린 무언가를 고치려고 시도한다면 무슨 일이 생길까요?
Listing 4-9의 코드를 시험해보세요. 스포일러 경고: 작동이 안될겁니다!

Filename: src/main.rs

```rs
fn main() {
  let s = String::from("hello");

  change(&s);
}

fn change(some_string: &String) {
  some_string.push_str(", world");
}
```

Listing 4-9: 빌린 값을 고치려 해보기

여기 오류를 보시죠:

```
error: cannot borrow immutable borrowed content `*some_string` as mutable
 --> error.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^
```

변수가 기본적으로 불변인 것처럼, 참조자도 마찬가지입니다. 우리가 참조하는 어떤 것을 변경하는것은 허용되지 않습니다.

## 가변 참조자 (Mutable References)
