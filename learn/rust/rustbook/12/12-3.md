# 모듈성과 에러처리의 향상을 위한 리팩토링

첫번째, 우리 `main` 함수는 현재 두 가지 작업을 수행합니다: 인자들을 분석하고 파일을 열지요. 이런 작은 함수에서, 이건 큰 문제가 안됩니다. 하지만 우리가 계속해서 `main`함수 안에 프로그램을 작성하여 커지게 되면, `main` 함수가 처리하는 작업의 수도 늘어나게 될 겁니다. 함수가 갖게되는 책임들만큼, 근원을 파악하기도, 테스트 하기에도, 부분 별로 나누지 않고는 수정하기도 어려워 집니다. 함수는 **나뉘어 하나의 작업에 대해서만 책임을 지는 것**이 더 좋은 구조입니다.

이 문제는 우리의 두 번째 문제와도 관련이 있습니다: `query`와 `filename` 은 프로그램의 설정을 저장하는 변수이고 `f`와 `contents` 같은 변수는 프로그램의 논리 수행에 사용됩니다. `main` 이 길어질수록 범위 내에 더 많은 변수가 생깁니다. 범위 내에 더 많은 변수가 존재할수록, 각각의 변수를 추적하기 힘들어집니다. 목적을 분명히 하기 위해 설정 변수를 그룹화하여 하나의 구조로 결합시키는 것이 좋습니다.

세 번째 문제는 파일 열기가 실패 할 경우 `expect`를 사용하여 오류 메시지를 출력해주는데, 에러 메시지가 `Something went wrong reading the file` 밖에 없습니다. 파일이 존재하지 않는 경우 외에도 파일 열기가 실패하는 경우들이 있습니다. 예를 들어 파일은 존재하지만 파일을 열 수 있는 권한이 없을 수 있습니다. 현재는 이런 상황에도 `Something went wrong reading the file` 이란 오류 메시지를 출력하여 사용자에게 잘못된 조언을 해주게 됩니다.

넷째, 우리는 서로 다른 오류를 다루기 위해 `expect`를 반복적으로 사용하고 있습니다. 헌데 만약 사용자가 충분한 인수를 지정하지 않고 프로그램을 실행하면 Rust의 "index out of bounds" 오류가 발생하는데 이는 문제를 명확하게 설명하지 않습니다. 우리가 모든 오류처리 코드를 한 군데 모아놓으면 후에 관리자는 오류처리 로직을 변경해야 할 때 오직 이 곳의 코드만 참고하면 되니 더 좋죠. 또한, 모든 오류 처리 코드를 한 곳에 저장하면 우리가 최종 사용자에게 도움이 되는 메시지를 출력하고 있는지 확신하는데도 도움이 됩니다.

## 바이너리 프로젝트를 위한 관심사의 분리

`main` 함수가 여러 작업에 책임을 갖게 되는 구조적 문제는 많은 바이너리 프로젝트에서 공통적입니다. 그래서 Rust 커뮤니티는 `main`이 커지기 시작할 때 바이너리 프로그램의 핵심기능을 나누기 위한 가이드라인 프로세스를 개발했습니다. 프로세스에는 다음 단계가 있습니다:

    1. 당신의 프로그램을 _main.rs_ 과 _lib.rs_ 로 나누고 프로그램의 로직을 _lib.rs_ 으로 옮깁니다.
    2. 커맨드라인 파싱 로직이 크지 않다면, _main.rs_ 에 남겨둬도 됩니다.
    3. 커맨드라인 파싱 로직이 복잡해지기 시작할거 같으면, _main.rs_ 에서 추출해서 _lib.rs_ 로 옮기세요.
    4. 이런 절차를 통해 `main` 함수에는 다음의 핵심 기능들만 남아있어야 합니다.
        - 인자 값들로 커맨드라인을 파싱하는 로직 호출
        - 다른 환경들 설정
        - lib.rs의 `run` 함수 호출
        - `run`이 에러를 리턴하면, 에러 처리.
