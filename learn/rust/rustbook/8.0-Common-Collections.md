# Common Collections

Rust's standard library
includes a number of very userful
data structures called _collections_.
Most other data types
represent one specific value,
but collections can contain multiple values.
Unlike the built-in array and tuple types,
the data these collections point
to is stored on the heap,
which means the amount of data does
not need to be known
at compile time
and can grow
or shrink as the program runs.
Each kind of collection has different capabilities
and costs,
and choosing an appropriate one
for your current situtation is a skill
you'll develop over tiem.
In this chapter,
we'll discuss three collections that are
used very often in Rust progarms:

- a _vector_ allows you to store a variable number of value next to each other.
- A _string_ is a collection of characters.
  We've mentioned the `String` type previously,
  but in this chpater we'll talk about it in depth.
- A _hash map_ allows you to associate a value
  with a particular key.
  It's particular implementation of the more general data structure called a _map_.

To learn about the other kinds of collections provided by the standard library,
see the documentation.

We'll discuss how to create and update vectors,
strings, and hash maps, as well as what makes each special.

## Storing Lists of Values with Vectors

The first collection type we'll look at is `Vec<T>`,
also known as a _vector_.
Vectors allow you to store more than one value
in a single data structure
that puts all the values next to each other in memory.
Vectors can only store values of the same type.
They are useful when you have a list of items,
such as the lines of text in a file or the prices of items in a shopping cart.

### creating a New Vector

To create a new, empty vector,
we can call the `Vec::new` function,
as shown in Listing 8-1.

```rs
  let v: Vec<i32> = Vec::new();
```

Listing 8-1: Creating a new, empty vector to hold values of type `i32`

Note that we added a type annotation here.
Because we aren't inserting any values
into this vector,
Rust doesn't know what kind of elements we intend to store.
This is an important point. Vectors are implemented using generics;
we'll cover how to use generics with your own types in Chapter 10.
For now, know that the `Vec<T>` type provided by
the standard library can hold any type,
and when a specific vector holds a specific type,
the type is specified within angle brackets.
In Listing 8-1, we've told Rust that the `Vec<T>` in `v` will hold elements of the `i32` type.

In more realistic code,
Rust can often infer the type of value
you want to store once you insert values,
so you rarely need to do this type annotation.
It's more common to create a `Vec<T>` that has initial values,
and Rust provides the `vec!` macro for convenience.
The macro will create a new vector that
holds the values you give it.
Listing 8-2 creates a new `Vec<i32>` that holds the values
`1`, `2`, and `3`.
The integer type is `i32` because that's the default
integer type,
as we discussed in the "Data Types" section of Chapter 3.

```rs
  let v = vec![1, 2, 3];
```

Listing 8-2: Creating a new vector containing values

Because we've given initial `i32` values,
Rust can infer that the type of `v` is `Vec<i32>`,
and the type annotation isn't nevessary.
Next, we'll look at how to modify a vector.

### Updating a Vector

To create a vector and then add elements to it,
we can use the `push` method,
as shown in Listing 8-3.

```rs
  let mut v = Vec::new();

  v.push(5);
  v.push(6);
  v.push(7);
  v.push(8);
```

Listing 8-3: Using the push method to add values to a vector

As with any variable,
if we want to be able to change its value,
we need to make it mutable using the `mut` keyword,
as discussed in Chapter 3.
The numbers we place inside are all of type `i32`,
and Rust infers this from the data,
so we don't need the `Vec<i32>` annotation.

### Dropping a vector Drops Its Elements

Like any other `struct`,
a vector is freed when it goes out of scope,
as annotated in Listingn 8-4.

```rs
{
  let v = vec![1, 2, 3, 4];

  // do stuff with v
} // <- v goes out of scope and is freed here
```

Listing 8-4: Showing where the vector and its elements are dropped

When the vector gets dropped,
all of its contents are also dropped,
meaning those integers it holds will be cleaned up.
This may seem like a straightforward point but can get a bit more
complicated when you start to introduce references to the elements of the vector.
Let's tackle that next!

### Reading Elements of Vectors

Now that you know how to create, update, and destroy vectors,
knowing how to read their contents is a good next step.
There are two ways to reference a value
stored in a vector.
In the examples,
we've annotated the types of the values
that are returned from these functions for
extra clarity.

Listing 8-5 shows both methods of accessing a value in a vector, either with indexing syntax or the get method.

```rs
  let v = vec![1, 2, 3, 4, 5];

  let third: &i32 = &v[2];
  println!("The third element is {}", third);

  match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
  }
```

Listing 8-5: Using indexing syntax or the get method to access an item in a vector

Note two details here.
First, we use the index value of `2`
to get the third element:
vectors are indexed by number,
starting at zero.
Second, the two ways to get the third element are
by using `&` and `[]`,
which gives us a reference,
or by using the `get` method with the index
passed as an argument,
which gives us an `Option<&T>`.

Rust has two ways to reference an element so you can
choose how the program behaves when you try to use an index
value that the vector doesn't have an element for.
As an example,
let's see what a program will do
if it has a vector that holds five elemtns
and then tries to access an element at index 100,
as shown in Listing 8-6.

```rs
  let v = vec![1, 2, 3, 4, 5];

  let does_not_exist = &v[100];
  let does_not_exist = v.get(100);
```

Listing 8-6: Attempting to access the element at index 100 in a vector containing five elements

When we run this code,
the first `[]` method will cause the program to panic
because it reference a nonexistent element.
This method is best used
when your program to crash if there's an attempt to access an element
past the end of the vector.

When the `get` method is passed an index
that is outside the vector,
it returns `None` without panicking.
You would use this method if accessing an element beyond the range
of the vector happens occasionally under normal circumstances.
Your code will then have logic to handle having
either `Some(&element)` or `None`,
as discussed in Chapter 6.
For example,
the index could be coming from a person
entering a number.
if they accidentally enter a number
that's too large and the program gets `None` value,
you could tell the user
how many items
are in the current vector
and give them another chance
to enter a valid value.
That would be more user-friendly than crashing the program due to a typo!
