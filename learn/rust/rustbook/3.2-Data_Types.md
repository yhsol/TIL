# Data Types

Every value in Rust is of a certain _data type_,
which tells Rust what kind of data is being specified so it knows
how to work with that data.
We'll look at two data types subsets:
scalar and compound.

Keep in mind that Rust is a _statically typed_ language,
which means that it must know the types
of all variables at compile time.
The compiler can usually infer what type we want to use based on the avlue and how we use it.
In cases when many types are possible,
such as when we converted a `String` to a numeric type using `parse` in the
"Comparing the Guess to the Secret Number" section in Chapter 2,
we must add a type annotaion, like this:

```rs
let guess: u32 = "42".parse().expect("Not a number!");
```

If we don't add the type annotation here,
Rust will display the following error,
which means the compiler needs more information from us to know which type we want to use:

```
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`

To learn more, run the command again with --verbose.

```

You'll see different type annotaions for other data types.

## Scalar Types

A _scalar_ type represents a single value.
Rust has four primary scalar types:
intergers, floating-point numbers, Booleans, and characters.
You may recognize these from other programming languages.
Let's jump into how thye work in Rust.

### Integer Types

An _integer_ is a number without a fractional component.
We used one integer type in Chapter 2,
the `u32` type.
This type declaration indicates that the value it's associated with sould be an unsigned integer (signed integer types start with `i`, instead of `u`)
that takes up 32 bits of space.
Table 3-1 shows the built-in integer types in Rust.
Each variant in the Signed and Unsigned columns (for example, `i16`)
can be used to declare the type of an integer value.

Table 3-1: Integer Types in Rust

| Length  | Signed  | Unsigned |
| ------- | ------- | -------- |
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `i16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

Each variant can be either signed or unsigned and has an explicit size.
_Signed_ and _unsigned_ refer to whter it's possible for the number to be negative

- in other words, wheter the number needs to have a signe with it (signed)
  or wheter it will only ever be positive and can therefore be represented without a sign (unsgined).
  It's like writing numbers on paper:
  when the sign matters,
  a number is shown with a plus sign or minus sign:
  however, when it's safe to assume the number is positive,
  it's shown with no sign.
  Signed numbers are stored using two's complement representation.

Each signed variant can store numbers from -(2n - 1) to 2n - 1 - 1 inclusive, where n is the number of bits that variant uses. So an i8 can store numbers from -(27) to 27 - 1, which equals -128 to 127. Unsigned variants can store numbers from 0 to 2n - 1, so a u8 can store numbers from 0 to 28 - 1, which equals 0 to 255.

Additionally, the `isize` and `usize` types depend on the kind of computer your program is running on:
64 bits if you're on a 64-bit architecture and 32 bits if you're on a 32-bit architecture.

You can write integer literals in any of forms shown in Table 3-2.
Note that all number literals except the byte literal allow a type suffix,
such as `57u8`, and `_` as a visual separator,
such as `1_000`.

Table 3-2: Integer Literals in Rust

| Number literals | Example     |
| --------------- | ----------- |
| Decimal         | 98_222      |
| Hex             | 0xff        |
| Octal           | 0o77        |
| Binary          | 0b1111_0000 |
| Byte(u8 only)   | b'A'        |

So how do you know which type of integer to use?
If you're unsure,
Rust's defaults are generally good choices,
and integer types default to `i32`:
this type is generally the fastest,
even on 64-bit systems.
The primary situation in which you'd use `isize` or `usize` is when
indexing some sort of collection.

> Integer Overflow
> Let’s say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, integer overflow will occur. Rust has some interesting rules involving this behavior. When you’re compiling in debug mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs. Rust uses the term panicking when a program exits with an error; we’ll discuss panics in more depth in the “Unrecoverable Errors with panic!” section in Chapter 9.  
> When you’re compiling in release mode with the --release flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping. In short, values greater than the maximum value the type can hold “wrap around” to the minimum of the values the type can hold. In the case of a u8, 256 becomes 0, 257 becomes 1, and so on. The program won’t panic, but the variable will have a value that probably isn’t what you were expecting it to have. Relying on integer overflow’s wrapping behavior is considered an error.  
> To explicitly handle the possibility of overflow, you can use these families of methods that the standard library provides on primitive numeric types:  
> Wrap in all modes with the wrapping*\* methods, such as wrapping_add
> Return the None value if there is overflow with the checked*\_ methods
> Return the value and a boolean indicating whether there was overflow with the overflowing\_\_ methods
> Saturate at the value's minimum or maximum values with saturating\_\* methods

## Flaoting-Point Types
