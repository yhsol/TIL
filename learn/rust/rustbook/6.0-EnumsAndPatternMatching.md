# Enums and Pattern Matching

In this chapter we'll look at enumerations,
also referred to as enums.
Enums allow you to define a type by enumerating its possible variants.
First, we'll define and use an enum to show how an enum can encode meaning along with data.
Next, we'll explore a particularly useful enum,
called `Option`,
which expresses that a value can be either something or nothing.
Then we'll look at how pattern matching in the `match` expression makes it easy to run different code for different values of an enum.
Finally, we'll cover how the `if let` construct is another convenient and concise idiom avaliable to you tu handle enums in your code.

Enums are a feature in many languages,
but their capabilities differ in each language.
Rust's enums are most similar to algebraic data types in functional languages,
such as F#, OCaml, and Haskell.

## Defining an Enum

Let's look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case.
Say we need to work with IP addresses.
Currently, two major standards are used for IP addreses:
version four and version six.
These are the only possiblilities for an IP address that our program will come across:
we can _enumerate_ all possible variants,
which is where enumeration gets its name.

Any IP address can be either a version four or a version six address,
but not both at the same time.
That property of IP addresses makes the enum data structure appropriate,
because enum values can only be one of its variants.
Both version four and version six addresses are still funamentally IP addresses,
so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.

We can express this concept in code by defining an `IpAddrKind` enumeration and listing the possiblbe kinds an IP address can be,
`V4` and `V6`.
These are the variants of the enum:

```rs
enum IpAddrKind {
    V4,
    V6
}
```

`IpAddrKind` is now a custom data type that we can use elsewhere in our code.

## Enum Values

We can create instances of each of the two variants of `IpAddrKind` like this:

```rs
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
```

Note that the variants of the enum are namespaced under its identifier,
and we use a double colon to separate the two.
The reason this is useful is that now both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type:
`IpAddrKind`.
We can then, for instance, define a function that takes any `IpAddrKind`:

```rs
fn route(ip_kind: IpAddrKind) {}
```

And we can call this function with either variant:

```rs
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
```

Using enums has even more advantages.
Thinking more about our IP address type,
at the moment we don't have a way to store that actual Ip address _data_;
we only know what _kind_ it is.
Given that you just learned about structs in Chater 5,
you might tackle this problems as shown in Listing 6-1

```rs
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
```

Listing 6-1: Storing the data and `IpAddrKind` variant of an IP address using a `struct`

Here, we've defined a struct `IpAddr` that has two fields:
a `kind` field that is of type `IpAddrKind` (the enum we defined previously) and an `address` field of type `String`.
We have two instances of this struct.
The first, `home`, has the value `IpAddrKind::V4` as its `kind` with associated address data of `127.0.0.1`.
the second instance, `loopback`, has the other variant of `IpAddrKind` as its `kind` value, `V6`,
and has address `::1` associated with it.
We've used a struct to bundle the `kind` and `address` values together,
so now the variant is assocated with the value.

We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct,
by putting data directly into each enum varinat.
This new definition of the `IpAddr` enum says that both `V4` and `V6` variants will have associated `String` values:

```rs
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
```

We attach data to each variant of the enum directly, so there is no need for an extra struct.
