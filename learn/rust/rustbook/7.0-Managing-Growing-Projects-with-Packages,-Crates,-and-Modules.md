# Managing Growing Projects with Packages, Crates, and Modules

As you write
large programs,
organizing your code will be important
because keeping track
of your entire program
in your head will become impossible.
By grouping related functionality
and separating code
with distinct features,
you'll clarify where to find code
that implements a particular feature
and where to go to change
how a feature works.

The programs we’ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we’ll cover in the “Cargo Workspaces” section in Chapter 14.

In addition to grouping functionality,
encapsulating implementation details
lets you reuse code at a higher level:
once you've implemented an operation,
other code can call that code
via the code's public interface without knowing how
the implementaion works.
The way you write code
defines which parts
are public for other code
to use and which parts are
private implementation details
that you reserve the
right to change.
This is another way to limit the amount of detail
you have to keep in you head.

A related concept is scope:
the nested context
in which code is written
has a set of names
that are defined as "in scope."
When reading, writing, and compiling code,
programmers and compilers need to
know whether a particular name at a
particular spot
refers to a variable, function, struct, enum, module, constant, or other item and what that item means.
You can create scopes
and change which names
are in or out of scope.
You can't have two items
with the same name in the
same scope;
tools are available to resolve name conflicts.

Rust has a number of features that allow you to
manage your code's organization,
including which details are exposed,
which details are private,
and what names are in each scope in you programs.
These features,
sometimes collectively referred
to as the _module system_,
include:

- **Pacakges**: A Cargo feature that lets you build, test, and share crates
- **Crates**: A tree of modules that produces a library or executable
- **Modules** and **use**: Let you control the organization, scope, and privacy of paths
- **Paths**: A way of naming an item, such as a struct, function, or module

In this chapter,
we'll cover all these features,
discuss how they interact,
and explain how to use them to manage scope.
By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!

## Packages and Crates

The first parts of the module system we’ll cover are packages and crates.
A crate is a binary or library.
The _crate root_ is a source file
that the Rust compiler starts from and makes up the root module
of your crate
(we'll explain modules in depth in the "Defining Modules to Control Scope and Privacy" section).
A _package_ is one or more crates that provide a set of functionality.
A package contains a **Cargo.toml** file
that describes how to build those crates.

Several rules determine
what a package can contain.
A package _must_ contain zero or one library crates,
and no more.
It can contain as many binary crates as you'd like,
but it must contain at least one crate (either library or binary)

Let's walk through
when we create a package.
we enter the command `cargo new`:

```
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

When we entered the command, Cargo created a _Cargo.toml_ file,
giving us a package.
Looking at the contents of _Cargo.toml_,
there's no mention of _src/main.rs_ because Cargo follows a convention
that _src/main.rs_ is the crate root
of a binary directory
contains _src/lib.rs_,
the package contains a library crate
with the same name as the package,
and _src/lib.rs_ is its crate root.
Cargo passes the crate root files
to `rustc` to build
the library or binary.

Here, we have a package that only
contains _src/main.rs_,
meaning it only contains a binary
crate named `my-project`.
If a package contains _src/main.rs_ and _src/lib.rs_,
it has two crates:
a library and a binary,
both with the same name
as the package.
A package can ahve multiple binary crates
by placing files in the _src/bin_ directory:
each file will be a separate binary crate.

A crate will group related functionality
together in a scope
so the functionality is easy to share between multiple projects,
For example,
the `rand` crate we used in Chapter 2
provides functionality that generates
random numbers.
We can use that functionality
in our own projects
by bringing the `rand` crate into our project's scope.
All the functionality provided
by the `rand` crate is accessible
through the crate's name, `rand`.

keeping a crate's functionality
in its own scope
clarifies whether particular functionality is defined in our crate
or the `rand` crate
and prevents potential confilcts.
For example,
the `rand` crate
provides a trait named `Rng`.
We can also define a `struct` named `Rng` in our own crate. Because a crate's functionality is namespaced in its own scope, when we add `rand` as a dependency,
the compiler isn't confused about
what the name `Rng` refers to.
In our crate,
it refers to the `struct Rng` that we defined.
We would access the `Rng` trait
from the `rand` crate as `rand::Rng`.

Let's move on and talk about the module system!

## Defining Modules to Control Scope and Privacy

In this section,
we'll talk about moduels
and other parts
of the module system,
namely _paths_ that
allow you to name items;
the `use` keyword that brings a path
into scope;
and the `pub` keyword to make items public.
We'll also discuss the `as` keyword,
external packages,
and the glob operator.
For now,
let's focus on modules!

_Modules_ let us organize code
within a crate into groups
for readability and easy reuse.
Modules also control the _privacy_ of items,
which is whether an item
can be used by outside code (public)
or is an internal implementation detail and not available for
outside use (private).

As an example,
let's write a library crate that
provides the functionality of a restaurant.
We'll define the signature of functions
but leave their bodies empty to concentrate on the
organization of the code,
rather than actually implement a restaurant in code.

In the restaurant industry,
some parts of a restaurant works,
we can organize the functions
into nested modules.
Create a new library named `restaurant`
by running `cargo new --lib restaurant;`
then put the code in Listing 7-1 into _src/lib.rs_
to define some modules and function signatures.

Filename: src/lib.rs

```rs
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

Listing 7-1: A `front_of_house` module containing other modules that then contain functions

We define a module
by starting with
the `mod` keyword and then
specify the name of the module
(in this case, `front_of_house`)
and place curly brackets
around the body
of the module.
Inside modules,
we can have other modules,
as in this case with the modules `hosting` and `serving`.
Modules can also hold
definitions for other items,
such as structs,
enums, constants, traits,
or -as in Listing 7-1- functions.

By using modeuls,
we can group related
definitions together
and name why they're related.
Programmers using this code would have an easier time
finding the definitions they wanted
to use because they could navigate
the code based on the groups
rather than having to read through
all the definitions.
Programmers adding new funcionality
to this code
would know where to place the code
to keep the program organized.

Earlier, we mentioned
that _src/main.rs_
and _src/lib.rs_
are called crate roots.  
The reason for their name
is that the contents of either of these
two files form a module named
`crate` at the root
of the crate's module structure,
known as the _module tree_.

Listing 7-2 shows the module tree for the structure in Listing 7-1.

```rs
crate
    - front_of_house
        - hosting
            - add_to_waitlist
            - seat_at_table
        - serving
            - take_order
            - serve_order
            - take_payment
```

Listing 7-2: The module tree for the code in Listing 7-1

This tree shows how
some of the modules nest inside
one another
(for example, `hosting` nests inside `front_of_house`).
The tree also shows that
some modules are _siblings_
to each other,
meaning thye're defined in the same module
(`hosting` and `serving` are defined within `front_of_house`).
To continue the familiy metaphor,
if module A is contained inside module B,
we say that module A is the _child_ of module B
and that module B is the _parent_ of module A.
Notice that the entire module tree is rooted
under the implicit module named `crate`.

The module tree might remind you of the
filesystem's directory tree on your computer;
this is a very apt comparison!
Just like directories in a filesystem,
you use modules to organize your code.
And just like files in a directory,
we need a way to find our modules.

## Paths for Referring to an Item in the Module Tree

To show Rust where to find an item in a module tree,
we use a path in the same way
we use a path when
navigating a filesystem.
If we want to call a function,
we need to know its path.

A path can take two forms:

- An _absolute path_ starts from a crate root by using a crate name
  or a literal `crate`.
- A _relative path_ starts from the current module and uses
  `self`, `super`, or an identifier in the current module.

Both absoulte and relative paths
are followed by one or more
identifiers separated by double colons(`::`).

Let's return to the example
in Listing 7-1.
How do we call the `add_to_waitlist` function?
This is the same as asking,
what's the path of the `add_to_waitlist` function?
In Listing 7-3,
we simplified our code a bit
by removing some of the modules and functions.
We'll show two ways to call the `add_to_waitlist` function
from a new function `eat_at_restaurant` defined
in the crate root.
The `eat_at_restaurant` function is part of our library crate's
public API, so we mark it with the `pub` keyword.
In the "Exposing Paths with the `pub` keyword" section,
we'll go into more detail about `pub`.
Note that this example won't compile just yet;
we'll explain why in a bit.

Filename: src/lib.rs

```rs
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

// 근데 여기서 hosting 이랑 add_to_waitlist 의 mod, fn 앞에 pub 을 쓰지 않으면 뭐라고 한다!

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

Listing 7-3: Calling the `add_to_waitlist` function using absolute and relative paths

The first time we call the add_to_waitlist function in eat_at_restaurant,
we use an absoulte path.
The `add_to_waitlist` function is defined in the same crate as
`eat_at_restaurant`, which means
we can use the `crate` keyword
to start an absolute path.

After `crate`,
we include each of the successive modules
until we make our way
to `add_to_waitlist`.
You can imagine a filesystem with the
same structure,
and we'd specify the path
`/front_of_house/hosing/add_to_waitlist` to run
the `add_to_waitlist` program;
using the `crate` name to start from the crate root is like using
`/` to start from the filesystem root in your shell.

The second time we call `add_to_waitlist` in `eat_at_restaurant`,
we use a relative path.
The path starts with `front_of_house`,
the name of the module
defined at the same level of the module tree
as `eat_at_restaurant`.
Here the filesystem equivalent would be using the path
`front_of_house/hosting/add_to_waitlist`.
Starting with a name means
that the path is relative.

Choosing whether to use a relative or absolute path is a decision you’ll make based on your project. The decision should depend on whether you’re more likely to move item definition code separately from or together with the code that uses the item.
For example,
if we move the `front_of_house` module and the
`eat_at_restaurant` function into a module named
`customer_experience`,
we'd need to update the absolute path to `add_to_waitlist`,
but the relative path would still
be valid.
if we moved the `eat_at_restaurant` function
separately into a module named `dining`,
the absolute path to the add_to_waitlist call would stay the same,
but the relative path would need to be updated.
Our preference is to specify absolute paths
because it's more likely to move code
definitions and item calls ndependently of each other.

Let's try compile Listing 7-3 and find out
why it won't compile yet! The error we get is shown in Listing 7-4.

```
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`

To learn more, run the command again with --verbose.
```

Listing 7-4: Compiler errors from building the code in Listing 7-3

The error messages say that module `hosting` is private.
In other words,
we have the correct paths for the `hosting` module
and the `add_to_waitlist` function,
but Rust won't let use use them because it doesn't have access to the private sections.

Modules aren't useful only for organizing your code.
They also define Rust's _privacy boundary_:
the line that encapsulates the implementation details
external code isn't allowed
to know about,
call, or rely on.
So, if you want to make an item like a function
or struct private, you put it in a module.

The way privacy works in Rust
is that all items
(functions, methods, structs, enums, modules, and constans)
are private by default.
Items in a parent module
can't use the private items
inside child modules, but items in child modules wrap and hide their implementation details, but the child modules can see the context in which they’re defined.
To continue with the restaurant metaphor,
think of the privacy rulse as being like the back office of a restaurant:
what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant in which they operate.

Rust chose to have the module system
function this way so that hiding inner
implementation details is the default.
That way,
you know which parts of the inner code you can change
without breaking outer code.
But you can expose inner parts of child modules'code
to outer ancestor modules
by using the `pub` keyword to make an item public.

### Exposing Paths with the pub keyword

Let's return to the error
in Listing 7-4 that told us the `hosting` module is private.
We want the `eat_at_restaurant` function in the parent module
to have access to the `add_to_waitlist` function in the child module,
so we mark the `hosting` module with the `pub` keyword,
as shown in Listing 7-5.

```rs
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

```

Listing 7-5: Declaring the hosting module as pub to use it from eat_at_restaurant

Unfortunately, the code in Listing 7-5 still results in an error, as shown in Listing 7-6.

```
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --> src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --> src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --> src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`

To learn more, run the command again with --verbose.
```

Listing 7-6: Compiler errors from building the code in Listing 7-5

What happend? Adding the `pub` keyword in front of `mod hosting`
makes the module public.
With this change,
if we can access `front_of_house`,
we can access `hosting`.
But the _content_ of `hosting` are still private;
making the module public doesn't make its contents public.
The `pub` keyword on a module
only lets code in its ancestor modules refer to it.

The errors in Listing 7-6 say that the add_to_waitlist function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.

Let’s also make the add_to_waitlist function public by adding the pub keyword before its definition, as in Listing 7-7.

Filename: src/lib.rs

```rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

Listing 7-7: Adding the pub keyword to mod hosting and fn add_to_waitlist lets us call the function from eat_at_restaurant

Now the code will compile!
Let's look at the absolute and the relative path and double-check why
adding the `pub` keyword
lets us use these paths
in `add_to_waitlist` with respect to the privacy rules.

In the absolute path, we start with crate, the root of our crate’s module tree. Then the front_of_house module is defined in the crate root. The front_of_house module isn’t public, but because the eat_at_restaurant function is defined in the same module as front_of_house (that is, eat_at_restaurant and front_of_house are siblings), we can refer to front_of_house from eat_at_restaurant. Next is the hosting module marked with pub. We can access the parent module of hosting, so we can access hosting. Finally, the add_to_waitlist function is marked with pub and we can access its parent module, so this function call works!

In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from front_of_house. The front_of_house module is defined within the same module as eat_at_restaurant, so the relative path starting from the module in which eat_at_restaurant is defined works. Then, because hosting and add_to_waitlist are marked with pub, the rest of the path works, and this function call is valid!

### Starting Relative Paths with super

We can also construct relative paths
that begin in the parent module by using `super`
at the start of the path.
This is like starting a filesystem path with the `..` systac.
Why would we want to do this?

Consider the code in Listing 7-8 that models the situation in which a chef fixes an incorrect order and personally brings it out to the customer. The function fix_incorrect_order calls the function serve_order by specifying the path to serve_order starting with super:

Filename: src/lib.rs

```rs
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
```

Listing 7-8: Calling a function using a relative path starting with super

The fix_incorrect_order function is in the back_of_house module, so we can use super to go to the parent module of back_of_house, which in this case is crate, the root. From there, we look for serve_order and find it. Success! We think the back_of_house module and the serve_order function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate’s module tree. Therefore, we used super so we’ll have fewer places to update code in the future if this code gets moved to a different module.

### Making Structs and Enums Public

We can also use pub to designate structs and enums as public, but there are a few extra details. If we use pub before a struct definition, we make the struct public, but the struct’s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a public back_of_house::Breakfast struct with a public toast field but a private seasonal_fruit field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what’s in season and in stock. The available fruit changes quickly, so customers can’t choose the fruit or even see which fruit they’ll get.

Filename: src/lib.rs

```rs
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // the next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```

Listing 7-9: A struct with some public fields and some private fields

Because the toast field in the back_of_house::Breakfast struct is public, in eat_at_restaurant we can write and read to the toast field using dot notation. Notice that we can’t use the seasonal_fruit field in eat_at_restaurant because seasonal_fruit is private. Try uncommenting the line modifying the seasonal_fruit field value to see what error you get!

Also, note that because `back_of_house::Breakfast`
has a private field,
the struct needs to provide a public associated function
that constructs an instacne of `Breakfast`
(we've named it `summer` here).
If `Breakfast` didn't have such a function,
we couldn’t create an instance of Breakfast in eat_at_restaurant because we couldn’t set the value of the private seasonal_fruit field in eat_at_restaurant.

In contrast, if we make an enum public, all of its variants are then public. We only need the pub before the enum keyword, as shown in Listing 7-10.

Filename: src/lib.rs

```rs
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

Listing 7-10: Designating an enum as public makes all its variants public

Because we made the Appetizer enum public, we can use the Soup and Salad variants in eat_at_restaurant. Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub.

There's one more situation
involving `pub` that we haven't covered,
and that is our last module system feature:
the `use` keyword.
We'll cover `use` by itself first,
and then we'll show how to combine `pub` and `use`.

## Bringing Paths into Scope with the use keyword
