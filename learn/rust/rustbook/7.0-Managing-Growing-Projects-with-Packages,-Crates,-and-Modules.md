# Managing Growing Projects with Packages, Crates, and Modules

As you write
large programs,
organizing your code will be important
because keeping track
of your entire program
in your head will become impossible.
By grouping related functionality
and separating code
with distinct features,
you'll clarify where to find code
that implements a particular feature
and where to go to change
how a feature works.

The programs we’ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we’ll cover in the “Cargo Workspaces” section in Chapter 14.

In addition to grouping functionality,
encapsulating implementation details
lets you reuse code at a higher level:
once you've implemented an operation,
other code can call that code
via the code's public interface without knowing how
the implementaion works.
The way you write code
defines which parts
are public for other code
to use and which parts are
private implementation details
that you reserve the
right to change.
This is another way to limit the amount of detail
you have to keep in you head.

A related concept is scope:
the nested context
in which code is written
has a set of names
that are defined as "in scope."
When reading, writing, and compiling code,
programmers and compilers need to
know whether a particular name at a
particular spot
refers to a variable, function, struct, enum, module, constant, or other item and what that item means.
You can create scopes
and change which names
are in or out of scope.
You can't have two items
with the same name in the
same scope;
tools are available to resolve name conflicts.

Rust has a number of features that allow you to
manage your code's organization,
including which details are exposed,
which details are private,
and what names are in each scope in you programs.
These features,
sometimes collectively referred
to as the _module system_,
include:

- **Pacakges**: A Cargo feature that lets you build, test, and share crates
- **Crates**: A tree of modules that produces a library or executable
- **Modules** and **use**: Let you control the organization, scope, and privacy of paths
- **Paths**: A way of naming an item, such as a struct, function, or module

In this chapter,
we'll cover all these features,
discuss how they interact,
and explain how to use them to manage scope.
By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!

## Packages and Crates

The first parts of the module system we’ll cover are packages and crates.
A crate is a binary or library.
The _crate root_ is a source file
that the Rust compiler starts from and makes up the root module
of your crate
(we'll explain modules in depth in the "Defining Modules to Control Scope and Privacy" section).
A _package_ is one or more crates that provide a set of functionality.
A package contains a **Cargo.toml** file
that describes how to build those crates.

Several rules determine
what a package can contain.
A package _must_ contain zero or one library crates,
and no more.
It can contain as many binary crates as you'd like,
but it must contain at least one crate (either library or binary)

Let's walk through
when we create a package.
we enter the command `cargo new`:

```
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

When we entered the command, Cargo created a _Cargo.toml_ file,
giving us a package.
Looking at the contents of _Cargo.toml_,
there's no mention of _src/main.rs_ because Cargo follows a convention
that _src/main.rs_ is the crate root
of a binary directory
contains _src/lib.rs_,
the package contains a library crate
with the same name as the package,
and _src/lib.rs_ is its crate root.
Cargo passes the crate root files
to `rustc` to build
the library or binary.

Here, we have a package that only
contains _src/main.rs_,
meaning it only contains a binary
crate named `my-project`.
If a package contains _src/main.rs_ and _src/lib.rs_,
it has two crates:
a library and a binary,
both with the same name
as the package.
A package can ahve multiple binary crates
by placing files in the _src/bin_ directory:
each file will be a separate binary crate.

A crate will group related functionality
together in a scope
so the functionality is easy to share between multiple projects,
For example,
the `rand` crate we used in Chapter 2
provides functionality that generates
random numbers.
We can use that functionality
in our own projects
by bringing the `rand` crate into our project's scope.
All the functionality provided
by the `rand` crate is accessible
through the crate's name, `rand`.

keeping a crate's functionality
in its own scope
clarifies whether particular functionality is defined in our crate
or the `rand` crate
and prevents potential confilcts.
For example,
the `rand` crate
provides a trait named `Rng`.
We can also define a `struct` named `Rng` in our own crate. Because a crate's functionality is namespaced in its own scope, when we add `rand` as a dependency,
the compiler isn't confused about
what the name `Rng` refers to.
In our crate,
it refers to the `struct Rng` that we defined.
We would access the `Rng` trait
from the `rand` crate as `rand::Rng`.

Let's move on and talk about the module system!
