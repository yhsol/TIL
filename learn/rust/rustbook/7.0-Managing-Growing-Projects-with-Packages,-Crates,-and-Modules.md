# Managing Growing Projects with Packages, Crates, and Modules

As you write
large programs,
organizing your code will be important
because keeping track
of your entire program
in your head will become impossible.
By grouping related functionality
and separating code
with distinct features,
you'll clarify where to find code
that implements a particular feature
and where to go to change
how a feature works.

The programs we’ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we’ll cover in the “Cargo Workspaces” section in Chapter 14.

In addition to grouping functionality,
encapsulating implementation details
lets you reuse code at a higher level:
once you've implemented an operation,
other code can call that code
via the code's public interface without knowing how
the implementaion works.
The way you write code
defines which parts
are public for other code
to use and which parts are
private implementation details
that you reserve the
right to change.
This is another way to limit the amount of detail
you have to keep in you head.

A related concept is scope:
the nested context
in which code is written
has a set of names
that are defined as "in scope."
When reading, writing, and compiling code,
programmers and compilers need to
know whether a particular name at a
particular spot
refers to a variable, function, struct, enum, module, constant, or other item and what that item means.
You can create scopes
and change which names
are in or out of scope.
You can't have two items
with the same name in the
same scope;
tools are available to resolve name conflicts.

Rust has a number of features that allow you to
manage your code's organization,
including which details are exposed,
which details are private,
and what names are in each scope in you programs.
These features,
sometimes collectively referred
to as the _module system_,
include:

- **Pacakges**: A Cargo feature that lets you build, test, and share crates
- **Crates**: A tree of modules that produces a library or executable
- **Modules** and **use**: Let you control the organization, scope, and privacy of paths
- **Paths**: A way of naming an item, such as a struct, function, or module

In this chapter,
we'll cover all these features,
discuss how they interact,
and explain how to use them to manage scope.
By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!

## Packages and Crates

The first parts of the module system we’ll cover are packages and crates.
A crate is a binary or library.
The _crate root_ is a source file
that the Rust compiler starts from and makes up the root module
of your crate
(we'll explain modules in depth in the "Defining Modules to Control Scope and Privacy" section).
A _package_ is one or more crates that provide a set of functionality.
A package contains a **Cargo.toml** file
that describes how to build those crates.

Several rules determine
what a package can contain.
A package _must_ contain zero or one library crates,
and no more.
It can contain as many binary crates as you'd like,
but it must contain at least one crate (either library or binary)

Let's walk through
when we create a package.
we enter the command `cargo new`:

```
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

When we entered the command, Cargo created a _Cargo.toml_ file,
giving us a package.
Looking at the contents of _Cargo.toml_,
there's no mention of _src/main.rs_ because Cargo follows a convention
that _src/main.rs_ is the crate root
of a binary directory
contains _src/lib.rs_,
the package contains a library crate
with the same name as the package,
and _src/lib.rs_ is its crate root.
Cargo passes the crate root files
to `rustc` to build
the library or binary.

Here, we have a package that only
contains _src/main.rs_,
meaning it only contains a binary
crate named `my-project`.
If a package contains _src/main.rs_ and _src/lib.rs_,
it has two crates:
a library and a binary,
both with the same name
as the package.
A package can ahve multiple binary crates
by placing files in the _src/bin_ directory:
each file will be a separate binary crate.

A crate will group related functionality
together in a scope
so the functionality is easy to share between multiple projects,
For example,
the `rand` crate we used in Chapter 2
provides functionality that generates
random numbers.
We can use that functionality
in our own projects
by bringing the `rand` crate into our project's scope.
All the functionality provided
by the `rand` crate is accessible
through the crate's name, `rand`.

keeping a crate's functionality
in its own scope
clarifies whether particular functionality is defined in our crate
or the `rand` crate
and prevents potential confilcts.
For example,
the `rand` crate
provides a trait named `Rng`.
We can also define a `struct` named `Rng` in our own crate. Because a crate's functionality is namespaced in its own scope, when we add `rand` as a dependency,
the compiler isn't confused about
what the name `Rng` refers to.
In our crate,
it refers to the `struct Rng` that we defined.
We would access the `Rng` trait
from the `rand` crate as `rand::Rng`.

Let's move on and talk about the module system!

## Defining Modules to Control Scope and Privacy

In this section,
we'll talk about moduels
and other parts
of the module system,
namely _paths_ that
allow you to name items;
the `use` keyword that brings a path
into scope;
and the `pub` keyword to make items public.
We'll also discuss the `as` keyword,
external packages,
and the glob operator.
For now,
let's focus on modules!

_Modules_ let us organize code
within a crate into groups
for readability and easy reuse.
Modules also control the _privacy_ of items,
which is whether an item
can be used by outside code (public)
or is an internal implementation detail and not available for
outside use (private).

As an example,
let's write a library crate that
provides the functionality of a restaurant.
We'll define the signature of functions
but leave their bodies empty to concentrate on the
organization of the code,
rather than actually implement a restaurant in code.

In the restaurant industry,
some parts of a restaurant works,
we can organize the functions
into nested modules.
Create a new library named `restaurant`
by running `cargo new --lib restaurant;`
then put the code in Listing 7-1 into _src/lib.rs_
to define some modules and function signatures.

Filename: src/lib.rs

```rs
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

Listing 7-1: A `front_of_house` module containing other modules that then contain functions

We define a module
by starting with
the `mod` keyword and then
specify the name of the module
(in this case, `front_of_house`)
and place curly brackets
around the body
of the module.
Inside modules,
we can have other modules,
as in this case with the modules `hosting` and `serving`.
Modules can also hold
definitions for other items,
such as structs,
enums, constants, traits,
or -as in Listing 7-1- functions.

By using modeuls,
we can group related
definitions together
and name why they're related.
Programmers using this code would have an easier time
finding the definitions they wanted
to use because they could navigate
the code based on the groups
rather than having to read through
all the definitions.
Programmers adding new funcionality
to this code
would know where to place the code
to keep the program organized.

Earlier, we mentioned
that _src/main.rs_
and _src/lib.rs_
are called crate roots.  
The reason for their name
is that the contents of either of these
two files form a module named
`crate` at the root
of the crate's module structure,
known as the _module tree_.

Listing 7-2 shows the module tree for the structure in Listing 7-1.

```rs
crate
    - front_of_house
        - hosting
            - add_to_waitlist
            - seat_at_table
        - serving
            - take_order
            - serve_order
            - take_payment
```

Listing 7-2: The module tree for the code in Listing 7-1

This tree shows how
some of the modules nest inside
one another
(for example, `hosting` nests inside `front_of_house`).
The tree also shows that
some modules are _siblings_
to each other,
meaning thye're defined in the same module
(`hosting` and `serving` are defined within `front_of_house`).
To continue the familiy metaphor,
if module A is contained inside module B,
we say that module A is the _child_ of module B
and that module B is the _parent_ of module A.
Notice that the entire module tree is rooted
under the implicit module named `crate`.

The module tree might remind you of the
filesystem's directory tree on your computer;
this is a very apt comparison!
Just like directories in a filesystem,
you use modules to organize your code.
And just like files in a directory,
we need a way to find our modules.
