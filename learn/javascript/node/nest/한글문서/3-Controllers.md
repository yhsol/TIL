# Controllers

- `컨트롤러는 들어오는 요청 request을 처리하고 응답 response을 클라이언트에 반환할 책임이 있습니다.`

클라이언트에서 요청이 들어오면 nest 프로그램에서 해당 요청을 받아야 한다. 그 요청을 받는 곳이 컨트롤러이다. 그리고 요청을 처리하고 다시 클라이언트로 응답을 보내는 곳도 컨트롤러이다. 즉 통로같은 것.

- `컨트롤러의 목적은 애플리케이션에 대한 특정 요청을 수신하는 것입니다. 라우팅 메커니즘은 어떤 컨트롤러가 어떤 요청을 수신하는지 제어합니다. 종종 각 컨트롤러에는 둘 이상의 라우트가 있으며 다른 라우트는 다른 작업을 수행할 수 있습니다.`

- `기본 컨트롤러를 만들기 위해 클래스와 데코레이터를 사용합니다. 데코레이터는 클래스를 필수 메타데이터와 연결하고 Nest가 라우팅 맵을 만들 수 있도록 합니다(요청을 해당 컨트롤러에 연결).`

- `@Get()`
  아무것도 설정하지 않으면 `/cats` 에 매핑되어 응답함
  `@Get('all-cats')` 와 같이 path 를 설정할 경우 `/cats/all-cats` 에 매핑되어 응답함

- `@Req()`
  핸들러는 종종 클라이언트 요청 세부정보에 액세스해야 함. 그럴 때 Request object 에 액세스 제공.
  `@Req()` 데코레이터를 추가하여 Nest에 주입하도록 지시하여 요쳥객체에 액세스 할 수 있음.

- GraphQL 을 사용할 경우 Controller 는 Resolver 로, `@Get()`, `@Req()` 는 `@Query`, `@Mutation` 으로 사용가능 한 듯(?)

- Route wildcards
  패턴 기반 라우트도 지원됩니다. 예를 들어 별표는 와일드카드로 사용되며 모든 문자조합과 일치합니다.
  `'ab*cd'` 라우트 경로는 `abcd`, `ab_cd`, `abecd` 등과 일치합니다. `?`, `+`, `*` 및 `()` 문자는 라우트 경로에 사용될 수 있으며 해당 정규표현식 대응 부분의 하위집합입니다. 하이픈(`-`)과 점(`.`)은 문자열 기반 경로로 문자 그대로 해석됩니다.

- Status code
  201인 POST 요청을 제외하고 응답 상태코드는 기본적으로 항상 200
  `@HttpCode(...)` 데코레이터를 추가하여 변경 가능함

- Redirection
  때때로 HTTP 상태코드 또는 리디렉션 URL을 동적으로 확인해야 할 수 있습니다. 다음과 같은 형태로 라우트 핸들러 메서드에서 객체를 반환하면 됩니다.
