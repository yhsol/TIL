# Chapter 2

## 리팩터링 원칙

- 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

- 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

- 프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 거이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.

이 사실은 켄트 백의 말을 떠올리게 해준다. "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요." 리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.

- 비유하면 지금 위치에서 동쪽으로 100km를 이동하려는데 그 사이를 숲이 가로막고 있다면, 좀 둘러가더라도 20km 북쪽에 있는 고속도로를 타는 편이 세 배나 빠를 수 있다. 다들 "직진!"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다. \_제시카 커(Jessica Kerr)

- 나는 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.

- 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자. \_켄트 벡

- 나는 이런 상황에 처하더라도 팀 전체가 래팩터링에 매달리는 데는 회의적이다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 누구든지 리팩터링해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다. 리팩터링이 코드를 깨트리지 않는다는 장점을 활용하는 것이다. 일부를 변경해도 모든 기능이 항상 올바르게 동작한다. 예컨데 라이브러리를 교체할 때는 기존 것과 새 것 모드를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다(이 전력을 추상화로 갈아타기(Branch by Abstraction)라 한다).

- 코드 리뷰에 리팩터링 활용하기

- 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다. 리팩터링을 활용하기 전에는 코드를 읽고, 그럭저럭 이해한 뒤, 몇 가지 개선 사항을 제시했다. 지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴본다. 쉽다면 실제로 리팩터링한다. 이 과정을 몇 번 반복하면 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다.

- 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다. 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문이다. 코드 리뷰를 이런 식으로 진행하면 훨씬 큰 성취감을 맛볼 수 있다.

- 하지만 내가 볼 때 사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드(clean code)'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

- 나는 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다고 생각하는 편이다. 이러한 경향은 진화형 아키텍처(evolutionary architecture) 원칙이 발전하는 계기가 됐다(진화형 아키텍처는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다).

- 성능 개선을 위한 세 번재 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안한 것이다. 즉, 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.

- hs: 리팩터링이 겉보기 동작을 그대로 유지한 채, 내부를 변경하여 경제적인 이득을 취하는 것이라는 것이 인상적이었다. 그러기 위해서 작은 단위로 실행하고, TDD 를 도입할 수도 있다. 당연하지만 TDD 를 위해서가 아니라 효율적인 개발을 위해 TDD 를 도입하는 것이고, TDD 를 비롯한 여러가지 장치들을 생각해 봄 직 하다. 전체적인 구조를 그려두되 말그대로 습관처럼 그것을 개선하고 나은 방향으로 개선해 나갈 수 있어야겠다. 코드리뷰에 리팩터링을 접목하는 부분도 재미있었는데, 코드리뷰는 책에서 언급된 것 처럼 '그럭저럭' 이 되기 쉬운 것 같다. 그렇지만 코드리뷰가 힘을 내려면 그럭저럭 보다는 조금 더 나아가면 좋다고 생각하고, 거기에 리팩터링을 활용해보는 것은 좋은 방법이 될 것 같다. 마지막에 인용한 '성능 개선을 위한 세 번재 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안한 것이다. 즉, 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.' 는 케빈 켈리의 68가지 조언 중 "Separate the processes of creation from improving. You can’t write and edit, or sculpt and polish, or make and analyze at the same time. If you do, the editor stops the creator. While you invent, don’t select. While you sketch, don’t inspect. While you write the first draft, don’t reflect. At the start, the creator mind must be unleashed from judgement.(창작과 개선과정을 분리하세요. 쓰는것과 편집하는것, 조각하고 다듬는 것, 만들고 분석하는 것을 동시에 할수는 없습니다. 동시에 한다면 내 안의 편집자가 창작자를 막게 됩니다. 발명하는 동안 선택하지 마세요. 스케치 하는동안 검사하지 마세요. 초안 작성중에는 반영하지 마세요. 처음에는 창작자의 마음이 판단으로부터 해방되어야 합니다.)" 가 생각났다. 창작과 개선이 둘 다 중요함도 인식하고, 둘이 다름도 인식해야 겠다고 생각한다.
