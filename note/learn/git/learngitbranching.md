# learngitbranching

[Learn Git Branching](https://learngitbranching.js.org/?locale=ko)

- **보면서 알게 된 TIP**
    - ; 으로 여러개의 명령을 이어서 사용할 수 있다.
    - 브랜치는 '참조' 이기 때문에 메모리나 디스크 공간에 부담이 되지 않는다.

- **git commit**
    - 커밋은 Git 저장소에 여러분의 디렉토리에 있는 모든 파일에 대한 스냅샷을 기록하는 것입니다.
    - Git은 가능한 한 커밋을 가볍게 유지하고자 하기때문에, 커밋할 때마다 디렉토리 전체를 복사하진 않습니다. 각 커밋은 저장소의 이전 버전과 다음 버전의 변경내역("delta"라고도 함)을 저장합니다. 그래서 대부분의 커밋이 그 커밋 위의 부모 커밋을 가리킵니다.

- **Git 브랜치**
    - 깃의 브랜치도 놀랍도록 가볍습니다. 브랜치는 특정 커밋에 대한 참조(reference)에 지나지 않습니다.
    - 브랜치를 많이 만들어도 메모리나 디스크 공간에 부담이 되지 않기 때문에, 여러분의 작업을 커다른 브랜치로 만들기 보다, 작은 단위로 잘게 나누는 것이 좋습니다.

- **브랜치와 합치기(Merge)**
    - Git의 합치기(merge)는 두 개의 부모(parent)를 가리키는 특별한 커밋을 만들어 냅니다. 두개의 부모가 있는 커밋이라는 것은 "한 부모의 모든 작업내역과 나머지 부모의 모든 작업, 그리고 그 두 부모의 모든 부모들의 작업내역을 포함한다"라는 의미가 있습니다.
    - 각 브랜치의 독립된 커밋을 합치는 것.
    - git merge <합칠 브랜치>

- **Git 리베이스(Rebase)**
    - 리베이스는 기본적으로 커밋들을 모아서 복사한 뒤, 다른 곳에 떨궈 놓는 것입니다.
    - git rebase <정렬하고자 하는 라인의 브랜치(?) → 확인필요>

- **Git에서 여기저기로 옮겨다니기**
    - Git의 고급기능들에 대해 더 알아보기 전에, 여러분의 프로젝트를 표현하는 커밋 트리(commit tree)에서 이동 할 수 있는 여러가지 방법들을 아는것이 중요합니다.
    여기저기 이동하는 것에 익숙해지면, 여러분이 다른 git 명령어들을 사용하는 능력도 아주 좋아질 것입니다!

    - HEAD
        - HEAD는 현재 체크아웃된 커밋을 가리킵니다. -- 다시 말하자면 현재 작업중인 커밋입니다.
        - HEAD는 항상 작업트리의 가장 최근 커밋을 가리킵니다. 작업트리에 변화를 주는 git 명령어들은 대부분 HEAD를 변경하는것으로 시작합니다.
        - 일반적으로 HEAD는 브랜치의 이름을 가리키고있습니다(bugFix와 같이). 커밋을 하게 되면, bugFix의 상태가 바뀌고 이 변경은 HEAD를 통해서 확인이 가능합니다.

        - HEAD 분리하기
            - HEAD를 분리한다는 것은 HEAD를 브랜치 대신 커밋에 붙이는 것을 의미합니다.

    - **상대 참조**
        - 상대 참조로 우리가 기억할 만한 지점(브랜치 bugFix라던가 HEAD라던가)에서 출발해서 이동하여 다른 지점에 도달해 작업을 할 수 있습니다.
            - 간단한 기능
                - 한번에 한 커밋 위로 움직이는 ^
                    - 참조 이름에 하나씩 추가할 때마다, 명시한 커밋의 부모를 찾게 됩니다.
                    - 참조인 HEAD도 상대참조를 위해 사용할 수 있습니다.
                - 한번에 여러 커밋 위로 올라가는 ~<num> - "~" 연산자
                    - 커밋트리에서 위로 여러 단계를 올라가고 싶을 경우
                    - (~) 틸드 연산자는 (선택적) 올라가고 싶은 부모의 갯수가 뒤에 숫자가 옵니다.

            - 브랜치 강제로 옮기기
                - 상대 참조를 사용하는 가장 일반적인 방법은 브랜치를 옮길 때 입니다. -f 옵션을 이용해서 브랜치를 특정 커밋에 직접적으로 재지정 할 수 있습니다.

                ```jsx
                git branch -f master HEAD~3

                // (강제로) master 브랜치를 HEAD에서 세번 뒤로 옮겼습니다. (three parents behind HEAD).
                ```

    - Git에서 작업 되돌리기
        - Git에는 작업한 것을 되돌리는 여러가지 방법이 있습니다. 변경내역을 되돌리는 것도 커밋과 마찬가지로 낮은 수준의 일(개별 파일이나 묶음을 스테이징 하는 것)과 높은 수준의 일(실제 변경이 복구되는 방법)이 있는데요, 여기서는 후자에 집중해 알려드릴게요.
        - Git에서 변경한 내용을 되돌리는 방법은 크게 두가지가 있습니다 
        -- 하나는 git reset을 쓰는거고, 다른 하나는 git revert를 사용하는 것입니다.

        - Git 리셋(reset)
            - git reset은 브랜치로 하여금 예전의 커밋을 가리키도록 이동시키는 방식으로 변경 내용을 되돌립니다. 이런 관점에서 "히스토리를 고쳐쓴다"라고 말할 수 있습니다. 즉, git reset은 마치 애초에 커밋하지 않은 것처럼 예전 커밋으로 브랜치를 옮기는 것입니다.

            ```jsx
            git reset HEAD~1
            ```

            그림에서처럼 master 브랜치가 가리키던 커밋을 C1로 다시 옮겼습니다; 이러면 로컬 저장소에는 마치 C2커밋이 아예 없었던 것과 마찬가지 상태가 됩니다.

        - Git 리버트(revert)
            - 각자의 컴퓨터에서 작업하는 로컬 브랜치의 경우 리셋(reset)을 잘 쓸 수 있습니다만, "히스토리를 고쳐쓴다"는 점 때문에 다른 사람이 작업하는 리모트 브랜치에는 쓸 수 없습니다.
            - 변경분을 되돌리고, 이 되돌린 내용을 다른 사람들과 공유하기 위해서는, git revert를 써야합니다. 예제로 살펴볼게요.

            ```jsx
            git revert HEAD
            ```

            어색하게도, 우리가 되돌리려고한 커밋의 아래에 새로운 커밋이 생겼습니다. `C2`라는 새로운 커밋에 *변경내용*이 기록되는데요, 이 변경내역이 정확히 `C2` 커밋 내용의 반대되는 내용입니다.

            리버트를 하면 다른 사람들에게도 변경 내역을 밀어(push) 보낼 수 있습니다.

    - 작업을 여기저기로 옮기기
        -