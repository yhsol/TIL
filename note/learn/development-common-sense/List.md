# Interview List

## 개발상식

- 객체 지향 프로그래밍이란 무엇인가?

  - 관리체계, 책장, 데이터, 코드, 복잡도, 정리
  - "객체"라는 Box 에 복잡한 대상(함수, 변수 등)을 잘 정리해 두는 것.
  - 복잡한 것을 함수에 담아서 정리(function Do() { ...복잡 } -> Do() 로 단순화) -> 함수가 다시 복잡(Do1(), Do2(), Do3()) -> 이것을 다시 객체에 정리 -> toy = { Do1(), Do2(), Do3(), ... } -> toy.Do1(), toy.Do2(), toy.Do3()
  - 재사용성이 높아진다. 자주 사용되는 로직을 잘 정리해두면(라이브러리로 만드는 등의 방식으로) 계속 사용할 수 있으며 신뢰성을 확보할 수 있다.
  - 따라서, 디버깅, 유지보수, 데이터 모델링시 객체와 매핑하는 것에 좋다.
  - 역할에 따라서 객체로 나눠서 정리하고, 각 객체에 더해서 가져야 할 특성을 상속을 통해 확장해 추가할 수 있다.
  - 문제
    - 객체가 상태를 갖게 됨. (state 를 갖게 되고, 그 state 에 대해 다양한 방식으로 오류가 생길 수 있음.)
    - 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 버그 발생 -> 함수형 프로그래밍 패러다임이 주목받는 이유.
  - 설계 원칙
    - 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙

- 함수형 프로그래밍이란?

  - 순수함수, 인풋-아웃풋, 주어지는 역할을 간섭, 참조 없이 수행 -> 결과값에 대한 신뢰 가능,
    독립성, 변수의 부서적인 값 변경등의 오류를 원천 배제
  - 순수함수 - 순수하게 정해진 역할을 수행하는 함수.
  - 선언형. 함수를 값으로 이해, 인자로 사용가능
    var say_it = function(given) { console.log(given) }
    const say_it = (given) => console.log(given)
  - imuutable, 일급 객체, 순수 함수.
  - 리액트의 함수형 컴포넌트를 생각하면 이해가 쉽다.
    예를 들어 어떤 string 이 들어왔을 때 h1 tag 로 감싸서 출력하는 컴포넌트를 작성했다면,
    여기서 이 컴포넌트는 string 이 무엇인지 알 지 못한다.
    그렇지만 정확히 그 string 을 h1 tag 로 감싸서 출력한다.
    이렇게 순수함수의 역할을 하고, 이러한 컴포넌트를 엮어서 프로그래밍을 구성해가는 것을
    함수형 프로그래밍이라고 이해할 수 있지 않을까 생각한다.

- RESTful API 란 무엇인가?

  - API - application programming interface
    - 소프트웨어가 통신하는 interface
  - RESTful API - http 환경에서 api 를 작성하는 형식. 약속.
  - 리소스는 uri 로 표현하며, 리소스가 가리키는 것은 명사로 명시적으로, 분명하게 써야함.
  - get, post, put, patch, delete 등을 명확하게 써야함.

  * RESTful 하게 API 를 디자인 한다는 것.

    1. 리소스와 행위를 명시적이고 직관적으로 분리
       - 리소스는 uri 로 표현. 리소스가 가리키는 것은 명사로 표현.
       - 행위는 HTTP Method 로 표현.
         GET / POST / PUT / PATCH / DELETE 을 분명한 목적으로 사용.
    2. Message 는 Header 와 Body 를 명확히 분리해서 사용.
       - Entity 의 내용은 body 에 담는다.
       - 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보,
         응답받고자 하는 MIME 타입 등은 header 에 담는다.
       - header 는 http header 와 http body 로 나눌 수도 있고,
         http body 에 들어가는 json 구조로 분리할 수도 있다.
    3. API 버전을 관리한다.
       - 환경은 항상 변하기 때문에 API 의 signature 가 변경될 수도 있음을 유의해야 함.
       - 특정 API 를 변경할 때는 반드시 하위호환성을 보장해야 한다.
    4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.
       - 브라우저는 form-data 형식의 submit 으로, 서버에서는 json 형태로 보내는 식의 분리보다는
         둘다 json 으로 보내든, 둘다 form-data 형식으로 보내든 하나로 통일한다.
       - 다른 말로 표현하자면 URI 가 플랫폼 중립적이어야 한ㄷ.

  * 장점
    1. Open API 를 제공하기 쉽다.
    2. 분산환경에는 부적합하다.
    3. HTTP 통신 모델에 대해서만 지원한다.

- TDD 란 무엇이며 어떠한 장점이 있는가?

  - 테스트 코드를 작성하고, 그 테스트를 통과하는 코드를 작성하는 것.
  - 신뢰도를 높일 수 있고, 리팩토링시에 보다 보장되는 환경에서 할 수 있음.

- MVC 패턴이란 무엇인가?

  ### web browser -> web server -> controller(servlet) -> model(with database, value object, 로직) -> cotroller -> view(jsp) -> controller -> web serber -> web browser

  - MVC 각 컴포넌트의 역할

    - CONTROLLER(컨트롤러)
      - 일종의 조정자
      - 클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델 컴포넌트를 호출.
      - 클라이언트가 보낸 데이터가 있다면, 모델에 전달하기 쉽게 데이터 가공.
      - 모델이 업무를 마치면 그 결과를 뷰에게 전달.
    - MODEL(모델)
      - 컨트롤러가 호출할 때, 요청에 맞는 역할을 수행한다.
      - 비즈니스 로직을 구현하는 영역으로, 응용프로그램에서 데이터를 처리하는 부분.
      - 비즈니스 로직이란 업무에 필요한 데이터 처리를 수행하는 응용프로그램의 일부.
      - DB에 연결하고, 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업 수행.
      - 상태의 변화가 있을 때 컨트롤러와 뷰에 통보해 후속 조치 명령을 받을 수 있게 한다.
    - VIEW(뷰)

      - 컨트롤러로부터 받은 모델의 결과값을 가지고 사용자에게 출력할 화면을 만드는 일을 한다.
      - 만들어진 화면을 웹브라우저에 전송하여 웹브라우저가 출력하게 하는 것이다.
      - 화면에 표시되는 부분으로 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나
        입력폼 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역이다.

    - 리액트에서라면 controller 는 app 또는 index 파일,
      model 은 로직을 담당하는 container 파일,
      view 는 presenter 라고 이해할 수도 있지 않을까.

* Git 과 GitHub 에 대해서

  - Git 은 버전관리를 위한 소프트웨어
  - GitHub 는 Git 으로 저장돼서 원격전송된 내역들이 저장되는 공간을 제공하는 서비스.

## 자료구조

- Array vs LinkedLlist

  - Array 는 순서 그대로 저장한다. 따라서 index 를 통해 해당 원소에 빠르게 접근 할 수 있다.
    그렇지만 삭제, 삽입 시에는 이 순서에 균열이 생기기 때문에 그 균열을 다시 조정해야하는 비용이 발생한다.
  - LinkedList 는 자료를 연결하는 지점을 만들어서 저장한다. 따라서 삭제와 삽입을 쉽게 할 수 있다.
    하지만 해당 위치, 원소를 탐색하는 비용이 높다.

- Stack and Queue (선형 구조)

  - Stack 은 나중에 들어간게 먼저 나온다. 차곡차곡 쌓여서 가장 위에 있는 것이 출력됨. Last in First out
    - 박스에 담는 것. 박스에 담고, 위에것을 먼저 꺼내는 것.
  - Queue 는 먼저 들어간게 먼저 나온다. 먼저 들어간게 가장 앞에 있다가 가장 먼저 출력됨. First in First out
    - 줄서기. waiting

- Tree (비 선형 구조)
  - 계층적 관계(Hierarchical Relationship)를 표현하는 자료구조.
  - Node, Edge, Root Node, Terminal Node, Internal Node
  - Binary Tree
  - Full Binary Tree
  - Complete Binary Tree
  - BST (Binary Search Tree)
    - 효율적인 탐색을 위한 저장방법
    - binary search 와 linked list 를 결합한 자료구조의 일종이다.
      이진 탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제가 가능하게 하기 위함.
- Binary Heap
  - 자료구조를 효율적으로 관리하는 방법?
  - Red Black Tree - 정의 - 특징 - 삽입 - 삭제
- Hash Table
  - hash function
  - Resolve Collision
    - Open Addressing
    - Separate Chaining
  - Resize
- Graph
  - Graph 용어 정리
  - Graph 구현
  - Graph 탐색
  - Minimum Spanning Tree
    - Kruskal algorithm
    - Prim algorithm

## 네트워크

- GET, POST 방식의 차이점

  - GET

    - GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url 에 담겨서 전송된다. 때문에 url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)

  - POST

    - POST 방식의 request 는 HTTP Message의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만하다.)

  - 우선 GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 갖고 있다고 볼 수 있는 것이다. 반면에 POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.
    부수적인 차이점을 좀 더 살펴보자면 GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다.

- TCP 3-way-handshake
- UDP 와 TCP 의 차이점

  - UDP
    - UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜 이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.
  - TCP
    - 대부분의 인터넷 응용 분야들은 신뢰성 과 순차적인 전달 을 필요로 한다. UDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP이다. TCP(Transmission Control Protocol, 전송제어 프로토콜)는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송 하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP 에서 연결 설정 (connection establishment)는 3-way-handshake를 통해 행해진다.
      모든 TCP 연결은 전이중(full-duplex), 점대점(point to point)방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2 개의 종단점을 가지고 있음을 의미한다. TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.

- HTTP 와 HTTPS 의 차이점

  - HTTP 는 데이터를 주고 받기 위한 통신 프로토콜.
    - 먼저 클라이언트에 접속 -> 클라이언트가 요청 -> 서버가 응답
    - stateless 라서 한번 왔다갔다하면 연결이 끊겨서 불특정 다수를 향한 서비스에 적합.
  - HTTP 의 문제점들

    - 보안
      - 평문 통신 - 도청 가능
      - 통신 상대 확인 하지 않음 - 위장 가능
      - 완정성을 증명할 수 없음 - 변조 가능
    - 해결 방법
      - 통신 자체를 암호화
        SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 다른 프로토콜을 조합함으로써
        HTTP 의 통신 내용을 암호화 할 수 있다. SSL 을 조합한 HTTP 를 HTTPS(HTTP Secure) or HTTP over SSL 이라고 한다.
      - 콘텐츠를 암호화
        HTTP 메시지에 포함되는 콘텐츠만 암호화. 암호화해서 전송하면 받는 측에서는 그 암호를 해독하여 출력하는 처리가 필요.

  - HTTPS
    HTTP 에 암호화와 인증, 그리고 완정성 보호를 더한 HTTPS
    - HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.
    - 모든 웹 페이지에서 HTTPS 를 사용하지 않는 이유
      평문 통신에 비해서 암호화 통신은 CPU 나 메모리 등 리소스가 많이 필요하다. 그렇기 때문에 통신할 때마다 암호화를 하면 서버 한대당 처리할 수 있는 리퀘스트의 수가 줄어든다. 그렇기 때문에 민감한 정보를 다룰 때만 HTTPS 에 의한 암호화 통신을 사용한다.

- DNS round robin 방식
- 웹 통신의 큰 흐름

## 운영체제

- 프로세스와 스레드의 차이

  - 프로세스

    - 프로세스는 큰 흐름, 스레드는 프로세스 안의 작은 흐름(들).
    - 기찻길을 예로 들면, 프로세스는 기차 라인(여러개의 기차가 다닐 수 있는 큰 라인),
      스레드는 기차. 라인을 따라 이동하며, 필요한 데이터를 가져와서(담아서) 처리하거나,
      당장 데이터가 없을 경우, 곁 라인으로 빠져서 데이터를 기다렸다가, 데이터가 왔을 때 다시 라인으로 합류한다.(비동기)

    - 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

  - 스레드
    - 스레드는 프로세스 내의 실행 단위. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
  - 멀티 스레드 vs 멀티 프로세스
    멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

- 스케줄러의 종류
  - 장기 스케줄러
  - 단기 스케줄러
  - 중기 스케줄러
- CPU 스케줄러
  - FCFS
  - SJF
  - SRT
  - Priority scheduling
  - RR
- 동기와 비동기의 차이
- 멀티스레드
  - 장점과 단점
- 프로세스 동기화
  - Critical Section
  - 해결책
- 메모리 관리 전략
  - 메모리 관리 배경
  - Paging
  - Segmentation
- 가상 메모리
  - 배경
  - 가상 메모리가 하는 일
  - Demand Paging(요구 페이징)
  - 페이지 교체 알고리즘
- 캐시의 지역성
  - Locality
  - Caching line

## 데이터베이스

- 데이터 베이스
  - 데이터 베이스를 사용하는 이유
  - 데이터베이스 성능
- index
  - index 란 무엇인가
  - index 의 자료구조
  - Primary index vs Secondary index
  - Composite index
  - Index 의 성능과 고려해야할 사항
- 정규화에 대해서
  - 정규화 탄생 배경
  - 정규화란 무엇인가
  - 정규화의 종류
  - 정규화의 장단점
- Transaction
  - 트랜잭션(Transaction) 이란 무엇인가?
  - 트랜잭션과 Lock
  - 트랜잭션의 특성
  - 트랜잭션의 상태
  - 트랜잭션을 사용할 때 주의할 점
- Statement vs PrepareStatement
- NoSQL
  - 정의
  - CAP 이론
    - 일관선
    - 가용성
    - 네트워크 분할 허용성
  - 저장방식에 따른 분류
    --Value Model
    - Document Model
    - Column Model

## 디자인 패턴

- Singleton

## 알고리즘

## 프론트엔드

- 브라우저의 동작 원리

  - Browser

    - 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

  - 요약
    HTML 마크업을 처리하고 DOM 트리를 빌드한다. ("무엇을" 그릴지 결정한다.)
    CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. ("어떻게" 그릴지 결정한다.)
    DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. ("화면에 그려질 것만" 결정)
    렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. ("Box-Model" 을 생성한다.)
    개별 노드를 화면에 페인트한다.(or 래스터화)

  - 흐름

    - html -> html parser -> dom tree
    - css -> css parser -> 스타일 규칙
    - 둘을 합해서 렌더 트리 구성.
    - 그리기
    - 표시

  - DOM
    "파싱 트리"는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. DOM은 문서 객체 모델(Document Object Model)의 준말이다. 이것은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점이다. 트리의 최상위 객체는 문서이다.

- Document Object Model(작성중)
  - Event bubbling and Capturing
  - Event delegation
- CORS

  - 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청 에 의해 요청된다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다. 이것을 Same-Origin-Policy(동일 근원 정책)이라고 한다. 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고, 포트도 같아야 함을 의미한다.(이 때, 서브 도메인 네임은 상관없다.)
  - CORS는
    타 도메인 간에 자원을 공유할 수 있게 해주는 것이다. Cross-Origin Resource Sharing 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 출처 집합을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.
  - JSONP

- 크로스 브라우징

  - 웹 표준에 따라 개발을 하여 서로 다른 OS 또는 플랫폼에 대응하는 것을 말한다. 즉, 브라우저의 렌더링 엔진이 다른 경우에 인터넷이 이상없이 구현되도록 하는 기술이다.
  - 공통요소로 웹 페이지를 제작하여 다른 환경에서도 동작하도록 하는 것.

- 웹 성능과 관련된 Issues

- SSR - CSR & SPA(CSR - SPA)

  - 기존 SSR 에서 자바스크립트의 활용도가 커지면서, 클라이언트에서 동적으로 많은 일을 할 수 있게 되면서,
    CSR 방식의 SPA 가 등장함.

    - SPA 는 한번의 페이지 로딩으로, 그 후에는 클라리언트에서 작업을 진행함으로써, 서버에 다시 요청하지 않아도 되므로
      빠른 인터렉션이 가능해짐.
      그렇지만 그러다보니 클라이언트가 무거워짐. 그래서 VIEW 에 집중 할 수 있게 하자는 react 가 등장함.

  - client side rendering 은 client 에서 많은 일을 함.<br />
    서버에서는 json 을 보내주는 역할을 하고, html 을 그리는 등의 역할을 클라이언트에서 담당하게 됨.<br/>
    -> client 무거워짐.<br />
    -> view 만 하자는 react 등장.

  - CSR

  - 필요한 부분만 읽으면 됨 -> 빠른 인터렉션.
  - 일관성 있는 코드.
  - 페이지를 읽는 시간, 자바스크립트를 읽는 시간,<br />
    자바스크립트가 페이지를 그리는 시간이 다 필요.<br />
    -> 초기 구동 속도 느려짐(그 이후에는 빠른 인터렉션)

  - 문제
    - 검색엔진 최적화 문제
      - 웹 크롤러, 봇들이 자바스크립트를 못읽음.<br />
        -> html 에서만 정보를 수집하게 되어 클라이언트 사이드 렌더링 되는 페이지를 빈 페이지로 인식.
    - 보안 문제
      - 쿠키말고는 사용자 정보를 저장할 공간 없음.
        - ssr 에서는 서버측에서 세션등으로 관리.

- SSR

  - CSR 의 반대를 생각하면 쉽다.
  - 컨텐츠를 처음 접하는 시점을 당길 수 있다.
  - 서버따로, 클라이언트따로 작성하던 코드 통합 가능.
  - SEO 도 OK

  - 인터렉션 문제
    - 매번 서버에 리퀘스트 요청을 통해야 하기 때문.
    - DOM 조작에서도 요청 과정과 탐색 비용으로 애먹고 있다.
    - REACT 가 많은 해결책을 제시했지만 두고 봐야함.

* 정리
  - CSR
    - 빠른 인터렉션과 일관된 코드
    - 자바스크립트를 읽는 시간이 필요해 초기 구동 느림.
    - 웹 크롤러, 봇이 자바스크립트를 못읽어서 SEO 문제.
    - 보안문제. 서버가 아닌 클라이언트에서 해야하고, 그러려면 쿠키로 해야함.
  - SSR
    - 서버가 많은 일.
    - 컨텐츠 접하는 시점 당길 수 있음.
    - 서버, 클라이언트 코드 통합.
    - SEO -> OK
    - 인터렉션 -> 매번 request 해야하고, DOM 조작에도 요청과정과 탐색비용이 듬.
  - CSR && SSR
    - 둘의 장단점이 각각 존재하므로 둘의 장점을 같이 쓰기 위해 노력하고 있다.

- CSS Methodology
- normalize.css vs reset.css

  - nomalize

    - 브라우저간 일관된 스타일링을 목표로 한다.

  - reset
    - 기본 제공되는 브라우저 스타일을 전부 제거.

- 자바스크립트 작동원리

  - 렌더링 엔진 vs 자바스크립트 엔진

    - 렌더링 엔진은 html, css 로 작성된 마크업 코드들을 콘텐츠로써 웹 페이지에 '렌더링' 하는 역할
    - 자바스크립트 엔진은 자바스크립트로 작성한 코드를 해석하고 실행하는 인터프리터.

  - call stack
    - 자바스크립트는 하나의 호출 스택을 사용한다. 즉, 하나의 함수가 실행되면, 이 함수의 실행이 끝날 때까지 다른 task 는 수행되지 않는다.
    - 요청이 들어오면, 순차적으로 호출 스택에 담아서 처리함.
      - 메소드가 실행될 때, call stack 에 새로운 프레임이 생기고 push 되고 실행이 끝나면 해당 프레임은 pop 되는 원리이다.

```
  function foo(b) {
    var a = 10
    return a + b
  }

  runction bar(x) {
    var y = 2
    return foo(x + y)
  }

  console.log(bar(1))
```

- 위 코드 실행 순서

  - bar -> 스택 프레임, 지역 변수, 인자 형성, 생성 -> foo 호출 -> return 하며 foo 는 pop -> bar 역시 return 하며 pop

  - heap

    - 동적으로 생성된 객체(인스턴스)는 힙(heap)에 할당. 대부분 구조화 되지 않는 '더미'같은 메모리 영역을 'heap' 이라고 한다.

  - task queue

    - 자바스크립트의 런타임 환경에서 처리해야 하는 task 들을 임시 저장하는 큐.
    - setTimeout 에서 delay 가 0 이더라도 먼저 처리되지 않는 것.
      이것은 비동기로 호출되는 함수들이 바로 call stack 에 쌓이는 것이 아니라 task queue 에 쌓이기 때문이다.
      task queue 는 call stack 이 다 비워졌을 때 실행된다.

  - event loop
    - event loop 는 call stack 과 queue 사이의 작업들을 확인하고, call stack 이 비워질 경우, queue 에서 작업을 꺼내어 call stack 에 넣는다.
  - 자바스크립트는 event loop 와 queue 를 통해서 비동기 작업을 한다.
    직접적인 작업은 web api 에서 처리되고, 그 작업들이 완료되면 요청시 등록했던 callback 이 queue 에 등록된다.
    event loop 는 이 작업을 queue 에서 꺼내어 처리한다.
    event loop 는 microtask queue 를 확인하여 작업이 있다면 call stack 에 넣는다.
    microtsak queue 가 비워져있다면 task queue 를 확인하여 작업이 있다면 call stack k에 넣는다.

  - 순서
    - microtask queue -> animation frame -> task queue

- hoist
  - es6 문법이 표준화되면서 크게 신경쓰지 않아도 되는 부분이 되었지만, 자바스크립트의 특성을 잘 보여주는 특성 중 하나.
  - 끌어올리기. 자바스크립트에서 끌어올려지는 것은 변수이다. var keyword 로 선언된 모든 변수 선언은 호이스트 된다.
  - 함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 정의한 함수의 유효범위는 전체 코드의 맨 처음부터 시작한다. 함수 선언이 함수 실행 부분보다 뒤에 있더라도 자바스크립트 엔진이 함수 선언을 끌어올리는 것을 의미한다. 함수 호이스팅은 함수를 끌어올리지만 변수의 값은 끌어올리지 않는다.
  - 선언 단계에서 선언이 소스코드의 어디에 위치하든 해당 스코프의 컴파일 단계에서 처리하게 되고, 그렇기 때문에 위치에 상관없이 값을 읽을 수 있다.

```
foo( );
function foo( ){
  console.log(‘hello’);
};
// console> hello
```

foo 함수에 대한 선언을 호이스팅하여 global 객체에 등록시키기 때문에 hello가 제대로 출력된다.

```
foo( );
var foo = function( ) {
  console.log(‘hello’);
};
// console> Uncaught TypeError: foo is not a function
```

두번째 예제의 함수 표현은 함수 리터럴을 할당하는 구조이기 때문에 호이스팅 되지 않으며, 그렇기 때문에 type error 가 발생한다.

- closure

  - 두개의 함수로 만들어진 환경으로 이러우진 객체의 한 종류.
  - 여기서 환경이라함은 클로저가 생성될 때 그 범위의 여러 지역변수들을 포함한 context 이다.
  - 클로져를 통해 비공개(private)속성/메소드, 공개속성/메소드 를 구현할 수 있다.

  - 클로져 생성

    - 내부 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용된다.
    - 내부 함수는 외부 함수의 실행 환경(execution environment)에서 실행된다.
    - 내부 함수에서 사용되는 변수 x 는 외부 함수의 변수 스코프에 있다.

  ```
  function outer() {
  var name = `closure`;
  function inner() {
    console.log(name);
  }
  inner();
  }
  outer();
  // console> closure
  ```

  outer함수를 실행시키는 context에는 name이라는 변수가 존재하지 않는다는 것을 확인할 수 있다. 비슷한 맥락에서 코드를 조금 변경해볼 수 있다.

```
var name = `Warning`;
function outer() {
  var name = `closure`;
  return function inner() {
    console.log(name);
  };
}

var callFunc = outer();
callFunc();
// console> closure
```

- 위 코드에서 callFunc를 클로저라고 한다. callFunc 호출에 의해 name이라는 값이 console 에 찍히는데, 찍히는 값은 Warning이 아니라 closure라는 값이다. 즉, outer 함수의 context 에 속해있는 변수를 참조하는 것이다. 여기서 outer함수의 지역변수로 존재하는 name변수를 free variable(자유변수)라고 한다.
  이처럼 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 클로저라고 한다. 보다 정확히는 외부 함수에 의해 반환되는 내부 함수를 가리키는 말이다.

  ```
  var color = 'red';
  function foo() {
    var color = 'blue'; // 2
    function bar() {
        console.log(color); // 1
    }
    return bar;
  }
  var baz = foo(); // 3
  baz(); // 4
  ```

```
  -  bar는 color를 찾아 출력하는 함수로 정의되었다.
  -  그리고 bar는 outer environment 참조로 foo의 environment를 저장하였다.
  -  bar를 global의 baz란 이름으로 데려왔다.
  -  global에서 baz(=bar)를 호출했다.
  -  bar는 자신의 스코프에서 color를 찾는다.
  -  없다. 자신의 outer environment 참조를 찾아간다.
  -  outer environment인 foo의 스코프를 뒤진다. color를 찾았다. 값은 blue이다.
  -  때문에 당연히 blue가 출력된다.

  이게 바로 클로저다. 그냥 단순하게 보면 "이 당연하게 왜?"라고 생각할 수 있지만, 조금 더 자세히 따져보도록 하자.

일단 중요한 부분은 2~4번, 그리고 7번이다. bar는 자신이 생성된 렉시컬 스코프에서 벗어나 global에서 baz라는 이름으로 호출이 되었고, 스코프 탐색은 현재 실행 스택과 관련 없는 foo를 거쳐 갔다. baz를 bar로 초기화할 때는 이미 bar의 outer lexical environment를 foo로 결정한 이후이다. 때문에, bar의 생성과 직접적인 관련이 없는 global에서 아무리 호출하더라도 여전히 foo에서 color를 찾는 것이다. 이런 bar(또는 baz)와 같은 함수를 우리는 클로저라고 부른다.

  - 즉 두개의 함수를 활용해 만든 환경을 글로벌에서 변수 선언하여 가져와서 사용할 때의 함수를 클로저라고 한다.

- this

  - 객체의 메서드를 호출할 때

    - 함수를 실행할 때 함수를 소유하고 있는 객체를 침조.
    - 즉 해당 메서드를 호출한 객체로 바인딩 된다.
    - 즉 해당 객체의 지역 변수값을 this 로 가져감.

  - 함수를 호출할 때
    - 해당 함수가 특정 객체의 메서드가 아닐 경우 전역 객체에 바인딩 됨.

- arrow function
  - 간결한 표현.
  - 화살표 함수는 익명함수.
  - 자신의 this, arguments, super, new.target 에 바인딩 하지 않는다.
  - 일반 함수에서 this 는 자기 자신을 this 로 정의한다.
    하지만 화살표 함수에서 this 는 상위 스코프의 this 와 동일한 값을 갖는다.
```
